<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- vscode Session 87011737-d43c-471c-899d-c1d5791302cb (2025-12-15 08:31Z) -->

# Running the KHDL project with Streamlit (2025-12-15 08:31Z)

_**User (2025-12-15 08:50Z)**_

chạy dự án khdl

---

_**Agent (model copilot/gpt-5.1-codex)**_

<tool-use data-tool-type="read" data-tool-name="copilot_readFile">
<details>
<summary>Tool use: **copilot_readFile** • Reading [](file:///d%3A/KHDL_cuoiky/README.md)</summary>


Read [](file:///d%3A/KHDL_cuoiky/README.md)

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="configure_python_environment">
<details>
<summary>Tool use: **configure_python_environment**</summary>

Additional data:

```json
{
  "vscodeToolId": "configure_python_environment",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Configuring a Python Environment",
  "resultDetails": {
    "input": "{\n  \"resourcePath\": \"d:\\\\KHDL_cuoiky\"\n}",
    "output": [
      {
        "type": "embed",
        "isText": true,
        "value": "A Python Environment has been configured.  \nFollowing is the information about the Python environment:\n1. Environment Type: VirtualEnvironment\n2. Version: 3.12.5.final.0\n\n3. Command Prefix to run Python in a terminal is: &#96;D:/KHDL_cuoiky/.venv/Scripts/python.exe&#96;\nInstead of running &#96;Python sample.py&#96; in the terminal, you will now run: &#96;D:/KHDL_cuoiky/.venv/Scripts/python.exe sample.py&#96;\nSimilarly instead of running &#96;Python -c \"import sys;....\"&#96; in the terminal, you will now run: &#96;D:/KHDL_cuoiky/.venv/Scripts/python.exe -c \"import sys;....\"&#96;\n"
      }
    ]
  },
  "isConfirmed": {
    "type": 1
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "dcb88d64-8194-4930-a9a0-a510c2936d91",
  "terminalCommandId": "tool-5be4a12c-f88b-409d-a542-4480ecfc7639",
  "commandLine": {
    "original": "cd /d D:\\KHDL_cuoiky; D:/KHDL_cuoiky/.venv/Scripts/python.exe -m streamlit run app.py",
    "toolEdited": "D:/KHDL_cuoiky/.venv/Scripts/python.exe -m streamlit run app.py"
  },
  "language": "pwsh",
  "terminalCommandState": {
    "timestamp": 1765788610230
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/3",
    "scheme": "vscode-terminal",
    "query": "command=tool-5be4a12c-f88b-409d-a542-4480ecfc7639"
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="get_terminal_output">
<details>
<summary>Tool use: **get_terminal_output**</summary>

Additional data:

```json
{
  "vscodeToolId": "get_terminal_output",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Checking background terminal output",
  "isConfirmed": {
    "type": 1
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

**Planning to read README for run instructions****Planning to run the project****Preparing to run Streamlit app****Preparing to summarize run status****Preparing final instructions**- Streamlit server for the KHDL project is up via `D:/KHDL_cuoiky/.venv/Scripts/python.exe -m streamlit run app.py`; open http://localhost:8501 (or the network URL shown) in your browser to use it.
- Stop it any time with Ctrl+C in that terminal, or let me know if you need it restarted.
- Natural next steps: 1) interact with the recommendations UI; 2) retrain artifacts with `train_models.py` if you update data.

---

_**User (2025-12-16 16:46Z)**_

giải thích các tính năng của web

---

_**Agent (model copilot/gpt-5.1-codex)**_

<tool-use data-tool-type="read" data-tool-name="copilot_readFile">
<details>
<summary>Tool use: **copilot_readFile** • Reading [](file:///d%3A/KHDL_cuoiky/app.py)</summary>


Read [](file:///d%3A/KHDL_cuoiky/app.py)

</details>
</tool-use>

---

**Planning to examine app.py****Listing key features with references**

I'll explain the main features of the app by referencing specific line ranges in [app.py](app.py#L27-L118), including configuration, selection controls, models, the recommendation slider, optional genre filtering, auto and manual logging, log history expander, and instructions for enabling logs, all laid out clearly in bullet points under a **Key Features** header.**Key Features**  
- Sidebar controls let you pick any rated `userId`, switch between content-based, SVD, or hybrid models, choose 5–20 recommendations, and optionally filter by genre to see how each algorithm behaves for the same profile (`undefined`).  
- Recommendations combine cached artifacts (content, collaborative, feature store, metadata) and rename scores consistently so the table always shows title, genres, average rating, rating count, and the active model’s score (`undefined`, `undefined`).  
- Genre filtering simply keeps rows whose `genres` string contains the entered keyword (case-insensitive), making it easy to focus on, say, Comedy or Sci-Fi picks (`undefined`).  
- When MySQL credentials are present, the app auto-logs each unique recommendation run (user, model, filters, exact movie list) to `user_interactions`, 

---

_**User (2025-12-16 16:47Z)**_

giải thích các tính năng của web bằng tiếng việt

---

_**Agent (model copilot/gpt-5.1-codex)**_

**Preparing feature explanation****Web Features**

- **Thanh điều khiển bên trái:** chọn `User ID` từ dữ liệu thật, đổi `Model` giữa Content-based, SVD, Hybrid và kéo thanh `Number of recommendations` (5–20). Ô `Optional genre filter` lọc kết quả theo thể loại, ví dụ nhập “Comedy”.
- **Bảng gợi ý chính:** phần “Recommended Titles” hiển thị các cột `Title`, `genres`, `avg_rating`, `rating_count`, `Model Score`. Danh sách luôn phản ánh cấu hình hiện tại; Hybrid dùng trọng số 0.55 giữa content và collaborative.
- **Ghi log lịch sử:** nếu đã cấu hình các biến môi trường MySQL (`MYSQL_HOST/PORT/USER/PASSWORD/DATABASE`), hệ thống tự kiểm tra `telemetry_available()`. Lúc đó:
  - Tự động ghi log khi thay đổi cấu hình (chỉ ghi một lần mỗi cấu hình, tránh trùng lặp).
  - Nút “Lưu thủ công” ép ghi lại log (bên trái, trong cùng container). Thông báo thành công/thất bại hiển thị ngay tại đó.
  - Nếu chưa bật MySQL, khối này hiển thị hướng dẫn cấu hình bằng tiếng Việt (“Thiết lập … để bật lưu lịch sử.”).
- **Khám phá lịch sử:** khi MySQL sẵn sàng, mục “Lịch sử tương tác (MySQL)” cho phép mở rộng, chọn số dòng gần nhất (slider 5–50) và xem DataFrame các log đã lưu.
- **Thông tin trợ giúp:** dòng chú thích dưới bảng nhắc người dùng điều chỉnh sidebar để so sánh hành vi các mô hình cho cùng một user; icon tải/xem toàn màn hình ở góc trên bên phải bảng giúp xuất CSV hoặc thu phóng.

Cần thêm mô tả chi tiết luồng tính toán hoặc cách cài đặt logging cứ báo nhé.

---

_**User (2025-12-16 16:49Z)**_

giải thcish tất cả các chức năng của web

---

_**Agent (model copilot/gpt-5.1-codex)**_

**Preparing detailed web app explanation**- Giao diện được dựng trong `app.py`; phần đầu tải toàn bộ artifact qua `get_models()` `undefined`, đảm bảo người dùng đã chạy `train_models.py` trước khi bật web.  
- Thanh sidebar gồm bốn điều khiển chính `undefined`: chọn `User ID` thực tế từ bộ `ratings`, chuyển mô hình (`Content-based`, `Collaborative (SVD)`, `Hybrid`), điều chỉnh số lượng gợi ý 5–20, và nhập bộ lọc thể loại tự do (không phân biệt hoa thường). Đây là nơi thay đổi cấu hình để so sánh hành vi các thuật toán.  
- Hệ thống dựng `HybridRecommender` với `alpha=0.55` `undefined` rồi tạo khung lịch sử người dùng. Mỗi lựa chọn mô hình kích hoạt bước recommend tương ứng `undefined`; kết quả được chuẩn hóa về cột `model_score` `undefined` và lọc theo thể loại nếu người dùng nhập `undefined`.  
- Bảng “Recommended Titles” hiển thị các cột chuẩn (`Title`, `genres`, `avg_rating`, `rating_count`, `Model Score`) `undefined`. Bảng Streamlit hỗ trợ sắp xếp, phóng to, xuất CSV trực tiếp từ UI và luôn phản chiếu cấu hình sidebar hiện tại.  
- Khối “Thiết lập MYSQL…” ở sidebar dùng chung với logic telemetry `undefined`:  
  - Khi các biến môi trường MySQL hợp lệ (`telemetry_available()`), app tự động log kết quả mới (dựa trên chữ ký `signature` chống trùng) và hiển thị thông báo thành công.  
  - Nút “Lưu thủ công” cho phép ép ghi lại log nếu muốn; thông báo kết quả ghi hiển thị ngay trong container.  
  - Nếu MySQL chưa bật, khối này chỉ dẫn cách thiết lập bằng tiếng Việt.  
- Mục “Lịch sử tương tác (MySQL)” ở cuối trang `undefined` mở ra bảng `fetch_recent_logs()` với slider chọn số dòng gần nhất (5–50). Mỗi log gồm `user_id`, loại mô hình, `movieId`, `model_score`, thời gian ghi.  
- Dòng chú thích dưới bảng chính `undefined` khuyến khích người dùng thử nhiều cấu hình để quan sát sự khác biệt giữa các thuật toán.  
- Tổng kết: web cho phép chọn người dùng, mô hình, số lượng gợi ý, lọc thể loại; xem danh sách phim với thống kê; tự động hoặc thủ công lưu lịch sử vào MySQL; và truy vấn lại lịch sử ngay trên giao diện.

---

_**User (2025-12-16 16:49Z)**_

web của tôi đc xây dựng từ file gì

---

_**Agent (model copilot/gpt-5.1-codex)**_

**Confirming web app structure**Ứng dụng web trong dự án này được dựng từ mã nguồn chính ở `app.py`. File đó khởi tạo Streamlit, tải các artifact mô hình (content-based, SVD, hybrid), xây dựng sidebar điều khiển, render bảng gợi ý và xử lý phần telemetry/MySQL. Nếu bạn mở hoặc chỉnh sửa giao diện web, đây là file cần làm việc.

---

_**User (2025-12-16 16:50Z)**_

giải thích về streamlit nó có giống html k 

---

_**Agent (model copilot/gpt-5.1-codex)**_

**Clarifying requested difference**Streamlit là một thư viện Python chuyên giúp dựng web UI cho dữ liệu/mô hình mà không cần viết HTML/CSS/JS thủ công. Thay vì phải tạo file `.html` với thẻ `<div>`, `<table>`, bạn chỉ viết Python giống như trong `app.py`: gọi `st.sidebar.selectbox(...)`, `st.dataframe(...)`, `st.slider(...)`. Khi chạy `streamlit run app.py`, Streamlit tự dựng server, sinh HTML/CSS/JS tương ứng và cập nhật UI theo các widget bạn khai báo. Vậy bản chất vẫn là web HTML ở phía trình duyệt, nhưng bạn không thao tác trực tiếp với mã HTML; Streamlit lo phần đó để bạn tập trung vào Python logic và dữ liệu.

---

_**User (2025-12-16 16:59Z)**_

vậy hãy làm web của tôi cụ thể và đẹp nhất có thể

---

_**Agent (model copilot/gpt-5.1-codex)**_

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #f6f7fb;
                --panel: #ffffff;
                --accent: #ff6b35;
                --accent-dark: #c24c1f;
                --muted: #4a4a68;
                --border: #e4e7ef;
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
            }
            .stApp {
                background: var(--surface);
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #10172a 0%, #1d253c 100%);
                color: #f1f5ff;
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            .hero-card {
                background: radial-gradient(circle at 10% 20%, rgba(255,107,53,0.12), transparent 60%),
                            linear-gradient(135deg, #10172a 0%, #182544 70%);
                padding: 32px;
                border-radius: 28px;
                color: #f8fbff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 60px rgba(14,22,36,0.35);
            }
            .hero-card h1 {
                margin-bottom: 8px;
                font-size: 2.3rem;
                letter-spacing: -0.02em;
            }
            .hero-card p {
                opacity: 0.85;
                max-width: 640px;
            }
            .stats-row {
                margin-top: 22px;
            }
            .stat-card {
                background: var(--panel);
                border-radius: 20px;
                padding: 18px 20px;
                border: 1px solid var(--border);
                box-shadow: 0 10px 30px rgba(15,23,42,0.07);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.75rem;
                letter-spacing: 0.08em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 1.8rem;
                font-weight: 600;
                margin-top: 6px;
            }
            .model-card {
                border-radius: 18px;
                padding: 20px 24px;
                background: var(--panel);
                border: 1px solid var(--border);
                margin-top: 24px;
            }
            .model-card h3 {
                margin-bottom: 4px;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: rgba(255,107,53,0.08);
                color: var(--accent-dark);
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.3);
            }
            .top-picks {
                margin: 18px 0 8px;
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.85rem;
                text-transform: uppercase;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .chip {
                background: var(--panel);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid var(--border);
                box-shadow: 0 5px 15px rgba(15,23,42,0.08);
                font-weight: 500;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


MODEL_DESCRIPTIONS = {
    "Content-based": "So khớp người dùng với các phim có vector nội dung tương tự dựa trên TF-IDF thể loại và mô tả.",
    "Collaborative (SVD)": "Dùng ma trận user-item và SVD để suy ra yếu tố tiềm ẩn, mạnh khi có lịch sử rating dày.",
    "Hybrid": "Kết hợp hai hệ trên với alpha 0.55 giúp cân bằng tính cá nhân hóa và khám phá." ,
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <p class="model-tag">MovieLens · Control Room</p>
            <h1>Recommendation Intelligence Board</h1>
            <p>Điều chỉnh các tham số ở thanh bên trái, quan sát ngay tức thì các bộ gợi ý được xếp hạng bởi nhiều chiến lược học máy khác nhau.</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Lượt đánh giá</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Điểm trung bình</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Thể loại ưa thích</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Recommended Titles")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, use_container_width=True, height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Điều chỉnh thanh bên để thấy rõ cách từng thuật toán phản hồi với cùng một người dùng."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="copilot_readFile">
<details>
<summary>Tool use: **copilot_readFile** • Reading [](file:///d%3A/KHDL_cuoiky/app.py)</summary>


Read [](file:///d%3A/KHDL_cuoiky/app.py)

</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #f6f7fb;
                --panel: #ffffff;
                --accent: #ff6b35;
                --accent-dark: #c24c1f;
                --muted: #4a4a68;
                --border: #e4e7ef;
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
            }
            .stApp {
                background: var(--surface);
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #10172a 0%, #1d253c 100%);
                color: #f1f5ff;
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            .hero-card {
                background: radial-gradient(circle at 10% 20%, rgba(255,107,53,0.12), transparent 60%),
                            linear-gradient(135deg, #10172a 0%, #182544 70%);
                padding: 32px;
                border-radius: 28px;
                color: #f8fbff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 60px rgba(14,22,36,0.35);
            }
            .hero-card h1 {
                margin-bottom: 8px;
                font-size: 2.3rem;
                letter-spacing: -0.02em;
            }
            .hero-card p {
                opacity: 0.85;
                max-width: 640px;
            }
            .stats-row {
                margin-top: 22px;
            }
            .stat-card {
                background: var(--panel);
                border-radius: 20px;
                padding: 18px 20px;
                border: 1px solid var(--border);
                box-shadow: 0 10px 30px rgba(15,23,42,0.07);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.75rem;
                letter-spacing: 0.08em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 1.8rem;
                font-weight: 600;
                margin-top: 6px;
            }
            .model-card {
                border-radius: 18px;
                padding: 20px 24px;
                background: var(--panel);
                border: 1px solid var(--border);
                margin-top: 24px;
            }
            .model-card h3 {
                margin-bottom: 4px;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: rgba(255,107,53,0.08);
                color: var(--accent-dark);
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.3);
            }
            .top-picks {
                margin: 18px 0 8px;
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.85rem;
                text-transform: uppercase;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .chip {
                background: var(--panel);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid var(--border);
                box-shadow: 0 5px 15px rgba(15,23,42,0.08);
                font-weight: 500;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


MODEL_DESCRIPTIONS = {
    "Content-based": "So khớp người dùng với các phim có vector nội dung tương tự dựa trên TF-IDF thể loại và mô tả.",
    "Collaborative (SVD)": "Dùng ma trận user-item và SVD để suy ra yếu tố tiềm ẩn, mạnh khi có lịch sử rating dày.",
    "Hybrid": "Kết hợp hai hệ trên với alpha 0.55 giúp cân bằng tính cá nhân hóa và khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <p class="model-tag">MovieLens · Control Room</p>
            <h1>Recommendation Intelligence Board</h1>
            <p>Điều chỉnh các tham số ở thanh bên trái, quan sát ngay tức thì các bộ gợi ý được xếp hạng bởi nhiều chiến lược học máy khác nhau.</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Lượt đánh giá</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Điểm trung bình</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Thể loại ưa thích</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Recommended Titles")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, use_container_width=True, height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Điều chỉnh thanh bên để thấy rõ cách từng thuật toán phản hồi với cùng một người dùng."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "547347ec-39c7-43c4-a1fd-9f8d9f6d2c47",
  "terminalCommandId": "tool-96e7018c-5590-4765-9714-dd2d764e9952",
  "commandLine": {
    "original": "cd /d D:\\KHDL_cuoiky; python - &lt;&lt;'PY'\nfrom pathlib import Path\npath = Path('app.py')\nmarkers = ['def inject_styles', 'def describe_user_profile', 'def render_top_picks', 'MODEL_DESCRIPTIONS', '&lt;div class=\"hero-card\"&gt;', 'class=\"stat-card\"', 'class=\"model-card\"', 'render_top_picks(display_df)', 'st.dataframe(display_df']\nwith path.open(encoding='utf-8') as f:\n    for idx, line in enumerate(f, 1):\n        for marker in markers:\n            if marker in line:\n                print(f\"{marker}:L{idx}\")\nPY"
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 1,
    "timestamp": 1765904137620,
    "duration": 968
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/3",
    "scheme": "vscode-terminal",
    "query": "command=tool-96e7018c-5590-4765-9714-dd2d764e9952"
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "5faed677-13c9-431e-a385-3bdf4d8a4f0d",
  "terminalCommandId": "tool-06534db3-e102-4b5a-866f-189720dcbab9",
  "commandLine": {
    "original": "cd /d D:\\KHDL_cuoiky; D:/KHDL_cuoiky/.venv/Scripts/python.exe -c \"from pathlib import Path; markers=['def inject_styles', 'def describe_user_profile', 'def render_top_picks', 'MODEL_DESCRIPTIONS', '&lt;div class=\\\\\\\"hero-card\\\\\\\"&gt;', 'stat-card', 'model-card', 'render_top_picks(display_df)', 'st.dataframe(display_df']; lines=Path('app.py').read_text(encoding='utf-8').splitlines();\nimport re\nfor idx,line in enumerate(lines,1):\n    for marker in markers:\n        if marker in line:\n            print(f'{marker}:L{idx}')\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 1,
    "timestamp": 1765904173413,
    "duration": 390
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/3",
    "scheme": "vscode-terminal",
    "query": "command=tool-06534db3-e102-4b5a-866f-189720dcbab9"
  },
  "terminalCommandOutput": {
    "text": "\u001b[91mSet-Location : A positional parameter cannot be found that accepts argument \r\n'D:\\KHDL_cuoiky'.\r\nAt line:1 char:1\r\n+ cd /d D:\\KHDL_cuoiky; D:/KHDL_cuoiky/.venv/Scripts/python.exe -c \"fro ...    \r\n+ ~~~~~~~~~~~~~~~~~~~~\r\n    + CategoryInfo          : InvalidArgument: (:) [Set-Location], ParameterB  \r\n   indingException\r\n    + FullyQualifiedErrorId : PositionalParameterNotFound,Microsoft.PowerShel  \r\n   l.Commands.SetLocationCommand\r\n\r\n\u001b[0m&lt;string&gt;:1: SyntaxWarning: invalid escape sequence '\\&gt;'\r\n  File \"&lt;string&gt;\", line 1\r\n    from pathlib import Path; markers=['def inject_styles', 'def describe_user_profile', 'def render_top_picks', 'MODEL_DESCRIPTIONS', '&lt;div class=\\\" hero-card\\\\\\&gt;',\r\n                                      ^\r\nSyntaxError: '[' was never closed\u001b[?1004h",
    "lineCount": 17
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "bc776586-d942-472b-b5cd-d419f00f12fd",
  "terminalCommandId": "tool-c460c5eb-5c19-47bc-b94a-5207beb4dbea",
  "commandLine": {
    "original": "Set-Location -Path D:\\KHDL_cuoiky; Select-String -Path app.py -Pattern \"def inject_styles\",\"def describe_user_profile\",\"def render_top_picks\",\"MODEL_DESCRIPTIONS\",\"hero-card\",\"stat-card\",\"model-card\",\"render_top_picks(display_df)\",\"st.dataframe(display_df\"",
    "toolEdited": "Select-String -Path app.py -Pattern \"def inject_styles\",\"def describe_user_profile\",\"def render_top_picks\",\"MODEL_DESCRIPTIONS\",\"hero-card\",\"stat-card\",\"model-card\",\"render_top_picks(display_df)\",\"st.dataframe(display_df\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 1,
    "timestamp": 1765904214107,
    "duration": 45
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/3",
    "scheme": "vscode-terminal",
    "query": "command=tool-c460c5eb-5c19-47bc-b94a-5207beb4dbea"
  },
  "terminalCommandOutput": {
    "text": "\u001b[91mSelect-String : The string st.dataframe(display_df is not a valid regular \r\nexpression: parsing \"st.dataframe(display_df\" - Not enough )'s.\r\nAt line:1 char:1\r\n+ Select-String -Path app.py -Pattern \"def inject_styles\",\"def describe ...    \r\n+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        \r\n    + CategoryInfo          : InvalidArgument: (:) [Select-String], ArgumentE  \r\n   xception\r\n    + FullyQualifiedErrorId : InvalidRegex,Microsoft.PowerShell.Commands.Sele  \r\n   ctStringCommand\r\n\u001b[0m\u001b[?1004h",
    "lineCount": 10
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "fe981c36-ee06-484a-be25-2f723aa1a8d9",
  "terminalCommandId": "tool-feb1541c-6d14-4249-9719-78eee109b86c",
  "commandLine": {
    "original": "Select-String -Path D:\\KHDL_cuoiky\\app.py -Pattern \"def inject_styles\",\"def describe_user_profile\",\"def render_top_picks\",\"MODEL_DESCRIPTIONS\",\"hero-card\",\"stat-card\",\"model-card\",\"render_top_picks(display_df)\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 0,
    "timestamp": 1765904221708,
    "duration": 61
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/3",
    "scheme": "vscode-terminal",
    "query": "command=tool-feb1541c-6d14-4249-9719-78eee109b86c"
  },
  "terminalCommandOutput": {
    "text": "\r\napp.py:26:def inject_styles() -&gt; None:\r\napp.py:52:            .hero-card {\r\napp.py:61:            .hero-card h1 {\r\napp.py:66:            .hero-card p {\r\napp.py:73:            .stat-card {\r\napp.py:91:            .model-card {\r\napp.py:98:            .model-card h3 {\r\napp.py:140:def describe_user_profile(user_history: pd.DataFrame, item_df:      \r\npd.DataFrame) -&gt; dict[str, str]:\r\napp.py:154:def render_top_picks(display_df: pd.DataFrame) -&gt; None:\r\napp.py:170:MODEL_DESCRIPTIONS = {\r\napp.py:244:        &lt;div class=\"hero-card\"&gt;\r\napp.py:257:            &lt;div class=\"stat-card\"&gt;\r\napp.py:267:            &lt;div class=\"stat-card\"&gt;\r\napp.py:277:            &lt;div class=\"stat-card\"&gt;\r\napp.py:285:    model_copy = MODEL_DESCRIPTIONS.get(model_choice, \"\")\r\napp.py:288:        &lt;div class=\"model-card\"&gt;\r\n\r\n\u001b[?1004h",
    "lineCount": 20
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #f6f7fb;
                --panel: #ffffff;
                --accent: #ff6b35;
                --accent-dark: #c24c1f;
                --muted: #4a4a68;
                --border: #e4e7ef;
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
            }
            .stApp {
                background: var(--surface);
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #10172a 0%, #1d253c 100%);
                color: #f1f5ff;
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            .hero-card {
                background: radial-gradient(circle at 10% 20%, rgba(255,107,53,0.12), transparent 60%),
                            linear-gradient(135deg, #10172a 0%, #182544 70%);
                padding: 32px;
                border-radius: 28px;
                color: #f8fbff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 60px rgba(14,22,36,0.35);
            }
            .hero-card h1 {
                margin-bottom: 8px;
                font-size: 2.3rem;
                letter-spacing: -0.02em;
            }
            .hero-card p {
                opacity: 0.85;
                max-width: 640px;
            }
            .stats-row {
                margin-top: 22px;
            }
            .stat-card {
                background: var(--panel);
                border-radius: 20px;
                padding: 18px 20px;
                border: 1px solid var(--border);
                box-shadow: 0 10px 30px rgba(15,23,42,0.07);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.75rem;
                letter-spacing: 0.08em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 1.8rem;
                font-weight: 600;
                margin-top: 6px;
            }
            .model-card {
                border-radius: 18px;
                padding: 20px 24px;
                background: var(--panel);
                border: 1px solid var(--border);
                margin-top: 24px;
            }
            .model-card h3 {
                margin-bottom: 4px;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: rgba(255,107,53,0.08);
                color: var(--accent-dark);
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.3);
            }
            .top-picks {
                margin: 18px 0 8px;
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.85rem;
                text-transform: uppercase;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .chip {
                background: var(--panel);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid var(--border);
                box-shadow: 0 5px 15px rgba(15,23,42,0.08);
                font-weight: 500;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


MODEL_DESCRIPTIONS = {
    "Content-based": "So khớp người dùng với các phim có vector nội dung tương tự dựa trên TF-IDF thể loại và mô tả.",
    "Collaborative (SVD)": "Dùng ma trận user-item và SVD để suy ra yếu tố tiềm ẩn, mạnh khi có lịch sử rating dày.",
    "Hybrid": "Kết hợp hai hệ trên với alpha 0.55 giúp cân bằng tính cá nhân hóa và khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <p class="model-tag">MovieLens · Control Room</p>
            <h1>Recommendation Intelligence Board</h1>
            <p>Điều chỉnh các tham số ở thanh bên trái, quan sát ngay tức thì các bộ gợi ý được xếp hạng bởi nhiều chiến lược học máy khác nhau.</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Lượt đánh giá</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Điểm trung bình</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Thể loại ưa thích</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Recommended Titles")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Điều chỉnh thanh bên để thấy rõ cách từng thuật toán phản hồi với cùng một người dùng."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "a9ed6b2a-7b68-4b31-9630-05f96e8311c4",
  "terminalCommandId": "tool-a486cc29-a114-4670-b97e-3c57ff550b87",
  "commandLine": {
    "original": "Select-String -Path D:\\KHDL_cuoiky\\app.py -Pattern \"st.dataframe\\(display_df\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 0,
    "timestamp": 1765904262266,
    "duration": 30
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/3",
    "scheme": "vscode-terminal",
    "query": "command=tool-a486cc29-a114-4670-b97e-3c57ff550b87"
  },
  "terminalCommandOutput": {
    "text": "\r\napp.py:303:    st.dataframe(display_df, width=\"stretch\", height=540)\u001b[?1004h",
    "lineCount": 4
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

**Designing comprehensive Streamlit UI update**

I’m planning how to enhance the app.py UI by injecting custom CSS for fonts and colors, restructuring layout with hero banners and metric columns, and adding user stats and top picks highlights. I’ll create helper functions to compute summaries and render components, then apply all these changes in one well-structured patch.**Preparing for final message with line references****Fixing trailing space in MODEL_DESCRIPTIONS****Planning line number extraction**

I’m figuring out how to get accurate line numbers for key functions and sections in app.py—like inject_styles and hero-card—to properly reference the new features. Since I already have the file content but no line numbers, I plan to run a Python script via run_in_terminal to scan and print line numbers for these markers, staying within the reading constraints while ensuring precise snippet links in the final response.**Clarifying Python command execution issue**

I'm figuring out why running the `python - <<'PY'` command triggered Streamlit unexpectedly—realizing PowerShell doesn’t support this heredoc syntax, so the command got misinterpreted and led to unintended behavior. I’m switching to using `python -c "code"` with the full path to the venv Python executable to properly run the script without the quoting problem and will test this approach next.**Refining PowerShell command execution approach**

I'm working through how to run Python code from PowerShell with proper quoting and escaping inside a JSON command string. To avoid complex quote escaping, I’m leaning toward using single quotes around Python code within PowerShell, letting Python interpret strings and newlines naturally. Another strategy is to use PowerShell’s Select-String to find marker patterns with line numbers directly by running it via run_in_terminal, which could greatly simplify retrieving line info without custom Python scripts. Let’s explore this approach!**Adjusting regex pattern for dataframe display****Updating streamlit dataframe parameters**

I’m updating the `st.dataframe` call to replace the soon-to-be-deprecated `use_container_width=True` with `width="stretch"` to prevent warnings and align with the new API before the 2025 deadline. This small patch will keep things future-proof and clean.**Preparing final line references****Finalizing UI update instructions****UI Enhancements**
- Injected a bespoke visual system (Google fonts, gradients, chips, sidebar palette) via `inject_styles()` so the page now has an intentional hero banner and consistent typography without hand-editing HTML `undefined`.
- Added `describe_user_profile()` and `render_top_picks()` to surface user insights (ratings count, average score, favorite genres) plus spotlight chips for the top three titles, giving the layout more storytelling context `undefined` and `undefined`.
- Introduced the `MODEL_DESCRIPTIONS` copy block and “Model Focus” card so each algorithm choice explains itself right above the table, keeping the UX self-explanatory `undefined` and `undefined`.
- Modernized the recommendations grid call to the new `width="stretch"` API to avoid the upcoming Streamlit deprecation warning while keeping the wide, full-bleed table presentation `undefined`.

1. Restart (or rerun) `streamlit run app.py` so the live session reloads the refreshed styling and layout.

---

_**User (2025-12-16 16:59Z)**_

hướng dẫn tôi chạy dư án này

---

_**Agent (model copilot/gpt-5.1-codex)**_

**Preparing run instructions****Run Project**

- **Chuẩn bị môi trường:** tạo venv và cài thư viện.
  - `python -m venv .venv`
  - `activate`
  - `pip install -r requirements.txt`
- **Tải dataset MovieLens:** `python `download_movielens.py` --output data/raw`
- **Tiền xử lý + train mô hình:** `python `train_models.py` --raw_dir data/raw --processed_dir data/processed --artifact_dir models/artifacts`
- **(Tuỳ chọn) Bật telemetry MySQL:** sao chép `.env.example` thành `.env`, điền `MYSQL_HOST/PORT/USER/PASSWORD/DATABASE`, sau đó export biến môi trường hoặc dùng `setx`.
- **Chạy giao diện Streamlit:** `D:\KHDL_cuoiky\.venv\Scripts\python.exe -m streamlit run app.py` (hoặc `streamlit run app.py` sau khi đã kích hoạt venv).
- **Mở trình duyệt:** truy cập URL mà Streamlit in ra (mặc định http://localhost:8501). Điều chỉnh thanh bên để khám phá content/collab/hybrid và xem bảng gợi ý mới.
- Nếu chỉnh sửa code hoặc styles trong `app.py`, dừng server bằng Ctrl+C rồi chạy lại để thấy thay đổi.

---

_**User (2025-12-16 17:00Z)**_

khi deploy dự án này rồi thì tôi có cần chạy trong vscode nữa k

---

_**Agent (model copilot/gpt-5.1-codex)**_

**Preparing to answer question**Không bắt buộc nữa. Sau khi bạn deploy xong lên môi trường chạy riêng (ví dụ Streamlit Community Cloud, Azure App Service…), ứng dụng sẽ tự được phục vụ ở đó. Bạn chỉ cần chạy trong VS Code khi muốn:

- cập nhật code, mô hình hoặc asset cục bộ;
- test nhanh trước khi đẩy phiên bản mới;
- xử lý sự cố mà bản deploy gặp phải.

Còn với bản đã triển khai ổn định, bạn chỉ việc dùng URL của môi trường đó, không phải mở VS Code hay chạy `streamlit run` trên máy cá nhân.

---

_**User (2025-12-16 17:00Z)**_

chạy dự án cho tôi

---

_**Agent (model copilot/gpt-5.1-codex)**_

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "a65cd10d-9854-4fa9-8233-0828f3e50222",
  "terminalCommandId": "tool-e3bc0e9d-5374-41ba-b877-f5e670ee6871",
  "commandLine": {
    "original": "cd /d D:\\KHDL_cuoiky; D:/KHDL_cuoiky/.venv/Scripts/python.exe -m streamlit run app.py",
    "toolEdited": "D:/KHDL_cuoiky/.venv/Scripts/python.exe -m streamlit run app.py"
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 1,
    "timestamp": 1765904874565,
    "duration": 449529
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/4",
    "scheme": "vscode-terminal",
    "query": "command=tool-e3bc0e9d-5374-41ba-b877-f5e670ee6871"
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="get_terminal_output">
<details>
<summary>Tool use: **get_terminal_output**</summary>

Additional data:

```json
{
  "vscodeToolId": "get_terminal_output",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Checking background terminal output",
  "isConfirmed": {
    "type": 1
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

**Preparing to run Streamlit app**- Streamlit server is up via `D:/KHDL_cuoiky/.venv/Scripts/python.exe -m streamlit run app.py`.
- Open http://localhost:8502 (or the network URL shown) to interact with the app.
- Stop it any time with Ctrl+C in that terminal, or let me know if you want it restarted later.

---

_**User (2025-12-16 17:11Z)**_

chỉnh lại chữ viết và giao diện cho tôi sau đó nêu ra những gì cần chỉnh để web nhìn chuyên nghiệp và có chiều sâu hơn

---

_**Agent (model copilot/gpt-5.1-codex)**_

<tool-use data-tool-type="read" data-tool-name="copilot_readFile">
<details>
<summary>Tool use: **copilot_readFile** • Reading [](file:///d%3A/KHDL_cuoiky/app.py)</summary>


Read [](file:///d%3A/KHDL_cuoiky/app.py)

</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


MODEL_DESCRIPTIONS = {
    "Content-based": "So khớp người dùng với các phim có vector nội dung tương tự dựa trên TF-IDF thể loại và mô tả.",
    "Collaborative (SVD)": "Dùng ma trận user-item và SVD để suy ra yếu tố tiềm ẩn, mạnh khi có lịch sử rating dày.",
    "Hybrid": "Kết hợp hai hệ trên với alpha 0.55 giúp cân bằng tính cá nhân hóa và khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <p class="model-tag">MovieLens · Control Room</p>
            <h1>Recommendation Intelligence Board</h1>
            <p>Điều chỉnh các tham số ở thanh bên trái, quan sát ngay tức thì các bộ gợi ý được xếp hạng bởi nhiều chiến lược học máy khác nhau.</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Lượt đánh giá</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Điểm trung bình</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Thể loại ưa thích</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Recommended Titles")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Điều chỉnh thanh bên để thấy rõ cách từng thuật toán phản hồi với cùng một người dùng."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <p class="model-tag">MovieLens · Control Room</p>
            <h1>Recommendation Intelligence Board</h1>
            <p>Điều chỉnh các tham số ở thanh bên trái, quan sát ngay tức thì các bộ gợi ý được xếp hạng bởi nhiều chiến lược học máy khác nhau.</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Lượt đánh giá</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Điểm trung bình</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Thể loại ưa thích</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Recommended Titles")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Điều chỉnh thanh bên để thấy rõ cách từng thuật toán phản hồi với cùng một người dùng."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Lượt đánh giá</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Điểm trung bình</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">Thể loại ưa thích</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Recommended Titles")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Điều chỉnh thanh bên để thấy rõ cách từng thuật toán phản hồi với cùng một người dùng."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Recommended Titles")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Điều chỉnh thanh bên để thấy rõ cách từng thuật toán phản hồi với cùng một người dùng."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Recommended Titles")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Điều chỉnh thanh bên để thấy rõ cách từng thuật toán phản hồi với cùng một người dùng."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "d300e26f-74e6-449d-8994-8e540cfe88bc",
  "terminalCommandId": "tool-26e200ad-ed58-4afd-9088-c2f4b027efb9",
  "commandLine": {
    "original": "Select-String -Path D:\\KHDL_cuoiky\\app.py -Pattern \"inject_styles\",\"hero-card\",\"stat-label\",\"context_line\",\"model-footnote\",\"st.subheader\\(\\\"\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 1,
    "timestamp": 1765904874145,
    "duration": 428
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/4",
    "scheme": "vscode-terminal",
    "query": "command=tool-26e200ad-ed58-4afd-9088-c2f4b027efb9"
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="get_terminal_output">
<details>
<summary>Tool use: **get_terminal_output**</summary>

Additional data:

```json
{
  "vscodeToolId": "get_terminal_output",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Checking background terminal output",
  "isConfirmed": {
    "type": 1
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "f4b7b40e-bdda-4e05-b9a3-605961c37522",
  "terminalCommandId": "tool-21870916-ac95-45da-a4a8-8d2b13f6d3e9",
  "commandLine": {
    "original": "Select-String -Path D:\\KHDL_cuoiky\\app.py -Pattern \"def inject_styles\",\"hero-card\",\"context_line\",\"model-footnote\",\"st.subheader\\(\\\"\",\"stat-label\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "timestamp": 1765904905330
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/4",
    "scheme": "vscode-terminal",
    "query": "command=tool-21870916-ac95-45da-a4a8-8d2b13f6d3e9"
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "b12581eb-b1ea-4839-abc3-f3f6534be7ab",
  "terminalCommandId": "tool-8785b759-9a27-464d-966e-df5c2ca3cdfb",
  "commandLine": {
    "original": "\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "timestamp": 1765904936166,
    "duration": 1
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/4",
    "scheme": "vscode-terminal",
    "query": "command=tool-8785b759-9a27-464d-966e-df5c2ca3cdfb"
  },
  "terminalCommandOutput": {
    "text": "PS D:\\KHDL_cuoiky&gt; \u001b[93mSelect-String \u001b[90m-Path \u001b[37mD:\\KHDL_cuoiky\\app.py \u001b[90m-Pattern \u001b[36m\"def inject_styles\"\u001b[90m,\u001b[36m\"hero-card\"\u001b[90m,\u001b[36m\"context_line\"\u001b[90m,\u001b[36m\"model-footnote\"\u001b[90m,\u001b[36m\"st.subheader\\(\\\"\",\"\u001b[37mstat-label\"\r\n&gt;&gt;\u001b[1C\u001b[91m^C\u001b[0m\u001b[?1004h",
    "lineCount": 3
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "4cfaa283-1b36-44be-899d-9595204e4297",
  "terminalCommandId": "tool-d4c93237-b6d5-45a3-8dcb-b6ca62cb5516",
  "commandLine": {
    "original": "Select-String -Path D:\\KHDL_cuoiky\\app.py -Pattern \"def inject_styles\",\"hero-card\",\"context_line\",\"model-footnote\",\"st.subheader\",\"stat-label\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "timestamp": 1765904960484
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/4",
    "scheme": "vscode-terminal",
    "query": "command=tool-d4c93237-b6d5-45a3-8dcb-b6ca62cb5516"
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "2d67cffc-2859-4587-b3c0-097e8b729554",
  "terminalCommandId": "tool-1607723e-cd07-424e-823e-fb01e0266cfa",
  "commandLine": {
    "original": "cd /d D:\\KHDL_cuoiky; D:/KHDL_cuoiky/.venv/Scripts/python.exe -c \"from pathlib import Path\ntext = Path('app.py').read_text(encoding='utf-8').splitlines()\nkeys = ['def inject_styles', 'hero-card', 'stat-label', 'context_line', 'model-footnote', 'st.subheader']\nfor i,line in enumerate(text,1):\n    for key in keys:\n        if key in line:\n            print(f'{key}:L{i}')\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "timestamp": 1765904977182,
    "duration": 0
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/4",
    "scheme": "vscode-terminal",
    "query": "command=tool-1607723e-cd07-424e-823e-fb01e0266cfa"
  },
  "terminalCommandOutput": {
    "text": "\u001b[37m&gt;&gt;\u001b[1C\u001b[91m^C\u001b[0m\u001b[?1004h",
    "lineCount": 1
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "c6a27eaa-aef1-4f5e-8a5d-15e515f48d71",
  "terminalCommandId": "tool-f7d45de7-d8df-4b68-b904-83b7aa9b6c5f",
  "commandLine": {
    "original": "cd /d D:\\KHDL_cuoiky; D:\\KHDL_cuoiky\\.venv\\Scripts\\python.exe -c \"from pathlib import Path; text=Path('app.py').read_text(encoding='utf-8').splitlines(); keys=['def inject_styles','hero-card','stat-label','context_line','model-footnote','st.subheader']; import sys; _=[sys.stdout.write(f'{key}:L{i}\\n') for i,line in enumerate(text,1) for key in keys if key in line]\"",
    "toolEdited": "D:\\KHDL_cuoiky\\.venv\\Scripts\\python.exe -c \"from pathlib import Path; text=Path('app.py').read_text(encoding='utf-8').splitlines(); keys=['def inject_styles','hero-card','stat-label','context_line','model-footnote','st.subheader']; import sys; _=[sys.stdout.write(f'{key}:L{i}\\n') for i,line in enumerate(text,1) for key in keys if key in line]\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 0,
    "timestamp": 1765905006911,
    "duration": 93
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/4",
    "scheme": "vscode-terminal",
    "query": "command=tool-f7d45de7-d8df-4b68-b904-83b7aa9b6c5f"
  },
  "terminalCommandOutput": {
    "text": "\u001b[36meys if key in line]\"\r\n\u001b[0mdef inject_styles:L26\r\nhero-card:L66\r\nhero-card:L76\r\nhero-card:L84\r\nhero-card:L91\r\nstat-label:L133\r\nmodel-footnote:L157\r\nhero-card:L327\r\nstat-label:L346\r\nstat-label:L356\r\nstat-label:L366\r\ncontext_line:L375\r\ncontext_line:L382\r\nmodel-footnote:L382\r\nst.subheader:L388\u001b[?1004h",
    "lineCount": 16
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

**Planning app.py UI and text updates****Planning UI and text refinement****Updating model descriptions dictionary****Updating hero HTML block and markdown****Updating stat labels text****Adding dynamic context and footnote to model card****Updating UI text elements****Updating CSS for hero-copy class****Preparing line number extraction for changes****Analyzing interrupted terminal commands****Preparing to rerun search with line numbers****Handling incomplete terminal commands****Adjusting search pattern for st.subheader****Troubleshooting multiline command issues****Debugging Python one-liner quoting issues****Summarizing UI changes and enhancement suggestions**

I'll list the key updates in `app.py` with exact line references for styles (L26-L175), hero block (L327-L335), stat cards (L340-L366), model context and footnote (L372-L384), and headings (L388-L396). After summarizing these, I'll provide a short numbered list of suggestions to deepen and professionalize the UI, such as animated transitions, richer visualizations, and session tracking. I'll also remind the user to rerun Streamlit with `streamlit run app.py` to see the changes. The response will be in Vietnamese as requested.**UI Refresh**
- Tập trung làm mới toàn bộ ngôn ngữ thị giác trong `inject_styles()` với palette đậm, font Clash Display + Space Grotesk, sidebar bo tròn và DataFrame dạng “glassmorphism” để bảng gợi ý có chiều sâu hơn `undefined`.
- Hero section được viết lại với copy súc tích (“MOVIELENS OPS · LIVE FEED”, meta badge…) để tạo cảm giác dashboard chuyên nghiệp `undefined`.
- Bộ thẻ chỉ số người dùng giờ dùng nhãn uppercase và giữ phong cách metric board đồng nhất `undefined`.
- Thẻ “Model Focus” bổ sung mô tả mới, cùng dòng footnote hiển thị cấu hình hiện tại (`user`, `top_k`, bộ lọc thể loại) giúp người xem hiểu ngữ cảnh ngay trên UI `undefined`.
- Khu vực kết quả và caption được Việt hóa lại (“Bảng xếp hạng đề xuất”, mô tả real-time) để đồng bộ giọng điệu `undefined`.

Chạy lại server bằng `streamlit run app.py` (hoặc nhấn Rerun trong UI) để tải giao diện mới.

**Để chuyên nghiệp & giàu chiều sâu hơn nữa**
1. Thêm phần “Insight” phụ với biểu đồ Plotly (ví dụ phân bố rating hoặc heatmap user–genre) ngay dưới stat cards nhằm kể chuyện dữ liệu, không chỉ hiển thị bảng.
2. Thiết kế bảng lịch sử/phiên sử dụng dạng timeline (Streamlit AgGrid hoặc `st.timeline`) để thấy được luồng thao tác và mô hình nào đang được ưu tiên.
3. Cung cấp bộ điều khiển theme nâng cao (tùy chọn Dark/Lite, chỉnh alpha hybrid) cùng tooltip giải thích mỗi widget; điều này tăng tính kiểm soát và giúp chia sẻ dashboard cho stakeholder không rành kỹ thuật.

---

_**User (2025-12-16 17:17Z)**_

Thêm phần “Insight” phụ với biểu đồ Plotly (ví dụ phân bố rating hoặc heatmap user–genre) ngay dưới stat cards nhằm kể chuyện dữ liệu, không chỉ hiển thị bảng cho tôi

---

_**Agent (model copilot/gpt-5.1-codex)**_

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import plotly.express as px
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import plotly.express as px
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[px.histogram, px.bar, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "8c5ac456-8311-4373-b8cd-a22e9d124ede",
  "terminalCommandId": "tool-4f63df42-b3ba-4364-a209-207198ea5a2c",
  "commandLine": {
    "original": "D:\\KHDL_cuoiky\\.venv\\Scripts\\python.exe -c \"from pathlib import Path; text=Path('app.py').read_text(encoding='utf-8').splitlines(); markers={'inject_styles':['def inject_styles'], 'genre_counts':['def _genre_counts'], 'insight_figs':['def build_insight_figures'], 'insight_section':['rating_fig, genre_fig'], 'plotly_chart':['st.plotly_chart'], 'model_card':['context_line ='], 'subheader':['st.subheader']};\nfor name, keys in markers.items():\n    for i,line in enumerate(text,1):\n        if any(key in line for key in keys):\n            print(f\"{name}:{i}\")\n            break\n\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 1,
    "timestamp": 1765905382608,
    "duration": 1005
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/4",
    "scheme": "vscode-terminal",
    "query": "command=tool-4f63df42-b3ba-4364-a209-207198ea5a2c"
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "281e011e-df66-40d7-a218-29996b784654",
  "terminalCommandId": "tool-e9378bc5-03b5-41c5-ae38-800ba3b2db9d",
  "commandLine": {
    "original": "Select-String -Path D:\\KHDL_cuoiky\\app.py -Pattern \"def inject_styles\",\"def _genre_counts\",\"def build_insight_figures\",\"rating_fig, genre_fig\",\"st.plotly_chart\",\"context_line =\",\"st.subheader\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 0,
    "timestamp": 1765905403234,
    "duration": 88
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/4",
    "scheme": "vscode-terminal",
    "query": "command=tool-e9378bc5-03b5-41c5-ae38-800ba3b2db9d"
  },
  "terminalCommandOutput": {
    "text": "\u001b[36m_chart\"\u001b[90m,\u001b[36m\"context_line =\"\u001b[90m,\u001b[36m\"st.subheader\"\r\n\r\n\u001b[0mapp.py:28:def inject_styles() -&gt; None:\r\napp.py:255:def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -&gt;\r\npd.DataFrame:\r\napp.py:265:def build_insight_figures(\r\napp.py:435:    rating_fig, genre_fig, rating_label, genre_label =\r\nbuild_insight_figures(user_history, item_df, ratings)\r\napp.py:439:        st.plotly_chart(rating_fig, use_container_width=True,\r\nconfig={\"displayModeBar\": False})\r\napp.py:442:        st.plotly_chart(genre_fig, use_container_width=True,\r\nconfig={\"displayModeBar\": False})\r\napp.py:446:    context_line = f\"User #{user_id} · Top {top_k}{genre_phrase}\"\r\napp.py:459:    st.subheader(\"Bảng xếp hạng đề xuất\")\r\n\r\n\u001b[?1004h",
    "lineCount": 16
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

**Planning addition of insight charts**

I'm mapping out how to add a new insights section below the stat cards using Plotly charts, focusing on rating distributions and genre breakdowns per user with sensible fallbacks to global data. I'll write helper functions to build these figures and then insert them neatly into the app with Streamlit columns, ensuring imports and data handling all fit seamlessly.**Adding insight helper functions**

I'm creating functions to build rating and genre distribution figures based on user history or overall ratings, handling empty cases with fallbacks and caching counts when needed. I'll make sure the visuals match a dark theme and integrate these figures into the app layout after existing stats, while considering dependencies like plotly.**Updating type hints for plotly figures****Positioning charts after stat cards****Verifying input handling and summarizing updates****Analyzing command auto-replacement issues****Summarizing final response details**

I'll craft a response that highlights the new Plotly section added with line references, mention the need to ensure Plotly is installed (like via `pip install plotly`), and remind to restart Streamlit to see changes. I'll note that tests weren't run and keep things clear and organized as requested.- Thêm Plotly Express (đã import ở `undefined`) cùng hai helper `_genre_counts()` và `build_insight_figures()` `undefined` để dựng biểu đồ thống kê nhanh cho cả phân bố rating và thể loại nổi bật.
- Ngay dưới cụm stat card, tính toán bộ `rating_fig`/`genre_fig` và hiển thị chúng trong hai cột Insight với tiêu đề động; mỗi biểu đồ Plotly được render phủ toàn chiều rộng và ẩn thanh công cụ nhằm giữ trải nghiệm dashboard gọn gàng `undefined`.
- Thẻ “Model Focus” vẫn hoạt động như trước nhưng nay nằm sau cụm Insight mới, giúp người dùng đọc dữ liệu định lượng trước khi chuyển sang diễn giải mô hình `undefined`.

Chưa chạy lại `streamlit run app.py`, vì vậy hãy khởi chạy/reload server để áp dụng giao diện mới. Ngoài ra, đảm bảo môi trường đã cài `plotly` (`pip install plotly`) nếu trước đó chưa có.

---

_**User (2025-12-16 17:21Z)**_

Thiết kế bảng lịch sử/phiên sử dụng dạng timeline (Streamlit AgGrid hoặc st.timeline) để thấy được luồng thao tác và mô hình nào đang được ưu tiên. cho tôi

---

_**Agent (model copilot/gpt-5.1-codex)**_

<tool-use data-tool-type="read" data-tool-name="copilot_readFile">
<details>
<summary>Tool use: **copilot_readFile** • Reading [](file:///d%3A/KHDL_cuoiky/src/telemetry.py)</summary>


Read [](file:///d%3A/KHDL_cuoiky/src/telemetry.py)

</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


def build_usage_timeline(logs: list[dict]) -> tuple[pd.DataFrame, Figure | None]:
    if not logs:
        return pd.DataFrame(), None

    timeline_df = pd.DataFrame(logs)
    if timeline_df.empty:
        return timeline_df, None

    if "created_at" in timeline_df:
        timeline_df["created_at"] = pd.to_datetime(timeline_df["created_at"])
    else:
        timeline_df["created_at"] = pd.to_datetime(timeline_df.index)

    timeline_df.sort_values("created_at", inplace=True)
    timeline_df["end_at"] = timeline_df["created_at"] + timedelta(minutes=2)
    timeline_df["hover"] = (
        "User #" + timeline_df["user_id"].astype(str)
        + " · Model: " + timeline_df.get("model_used", pd.Series("?", index=timeline_df.index)).astype(str)
        + "<br>Movie: " + timeline_df.get("movie_id", pd.Series("-", index=timeline_df.index)).astype(str)
        + "<br>Score: " + timeline_df.get("score_shown", pd.Series("-", index=timeline_df.index)).astype(str)
        + "<br>Action: " + timeline_df.get("action", pd.Series("-", index=timeline_df.index)).astype(str)
    )

    fig = px.timeline(
        timeline_df,
        x_start="created_at",
        x_end="end_at",
        y="user_id",
        color="model_used",
        hover_data={"hover": True, "movie_id": False},
        labels={"user_id": "User", "model_used": "Model"},
        color_discrete_sequence=["#ff6b35", "#8aa1ff", "#46d4a5", "#f7b955"],
    )
    fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=60, r=20, t=30, b=20),
        legend_title_text="Thuật toán",
        yaxis=dict(title="User", tickmode="linear"),
        height=320,
    )
    fig.update_traces(hovertemplate="%{customdata[0]}")
    return timeline_df, fig


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


def build_usage_timeline(logs: list[dict]) -> tuple[pd.DataFrame, Figure | None]:
    if not logs:
        return pd.DataFrame(), None

    timeline_df = pd.DataFrame(logs)
    if timeline_df.empty:
        return timeline_df, None

    if "created_at" in timeline_df:
        timeline_df["created_at"] = pd.to_datetime(timeline_df["created_at"])
    else:
        timeline_df["created_at"] = pd.to_datetime(timeline_df.index)

    timeline_df.sort_values("created_at", inplace=True)
    timeline_df["end_at"] = timeline_df["created_at"] + timedelta(minutes=2)

    def _field(name: str, fallback: str = "-") -> pd.Series:
        series = timeline_df.get(name)
        if series is None:
            return pd.Series([fallback] * len(timeline_df), index=timeline_df.index)
        return series.fillna(fallback).astype(str)

    timeline_df["hover"] = (
        "User #" + timeline_df["user_id"].astype(str)
        + " · Model: " + _field("model_used", "?")
        + "<br>Movie: " + _field("movie_id")
        + "<br>Score: " + _field("score_shown")
        + "<br>Action: " + _field("action")
    )

    fig = px.timeline(
        timeline_df,
        x_start="created_at",
        x_end="end_at",
        y="user_id",
        color="model_used",
        hover_name="hover",
        labels={"user_id": "User", "model_used": "Model"},
        color_discrete_sequence=["#ff6b35", "#8aa1ff", "#46d4a5", "#f7b955"],
    )
    fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=60, r=20, t=30, b=20),
        legend_title_text="Thuật toán",
        yaxis=dict(title="User", tickmode="linear"),
        height=320,
    )
    return timeline_df, fig


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = fetch_recent_logs(limit=limit)
            if logs:
                log_df = pd.DataFrame(logs)
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles() -> None:
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


def build_usage_timeline(logs: list[dict]) -> tuple[pd.DataFrame, Figure | None]:
    if not logs:
        return pd.DataFrame(), None

    timeline_df = pd.DataFrame(logs)
    if timeline_df.empty:
        return timeline_df, None

    if "created_at" in timeline_df:
        timeline_df["created_at"] = pd.to_datetime(timeline_df["created_at"])
    else:
        timeline_df["created_at"] = pd.to_datetime(timeline_df.index)

    timeline_df.sort_values("created_at", inplace=True)
    timeline_df["end_at"] = timeline_df["created_at"] + timedelta(minutes=2)

    def _field(name: str, fallback: str = "-") -> pd.Series:
        series = timeline_df.get(name)
        if series is None:
            return pd.Series([fallback] * len(timeline_df), index=timeline_df.index)
        return series.fillna(fallback).astype(str)

    timeline_df["hover"] = (
        "User #" + timeline_df["user_id"].astype(str)
        + " · Model: " + _field("model_used", "?")
        + "<br>Movie: " + _field("movie_id")
        + "<br>Score: " + _field("score_shown")
        + "<br>Action: " + _field("action")
    )

    fig = px.timeline(
        timeline_df,
        x_start="created_at",
        x_end="end_at",
        y="user_id",
        color="model_used",
        hover_name="hover",
        labels={"user_id": "User", "model_used": "Model"},
        color_discrete_sequence=["#ff6b35", "#8aa1ff", "#46d4a5", "#f7b955"],
    )
    fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=60, r=20, t=30, b=20),
        legend_title_text="Thuật toán",
        yaxis=dict(title="User", tickmode="linear"),
        height=320,
    )
    return timeline_df, fig


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = list(fetch_recent_logs(limit=limit))
            if logs:
                log_df, timeline_fig = build_usage_timeline(logs)
                if timeline_fig is not None:
                    st.plotly_chart(timeline_fig, use_container_width=True, config={"displayModeBar": False})
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "ce951754-306e-4526-ae06-ad8c5f08ca75",
  "terminalCommandId": "tool-31412ed1-44ba-4388-a380-91f6d69d9f75",
  "commandLine": {
    "original": "D:\\KHDL_cuoiky\\.venv\\Scripts\\python.exe -c \"from pathlib import Path; lines=Path('app.py').read_text(encoding='utf-8').splitlines(); markers={'timeline_func':'def build_usage_timeline','timeline_plot':'st.plotly_chart(timeline_fig','logs_section':'with st.expander(\"Lịch sử tương tác (MySQL)\"'}\nfor name, marker in markers.items():\n    for idx,line in enumerate(lines,1):\n        if marker in line:\n            print(f\"{name}:L{idx}\")\n            break\n\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 1,
    "timestamp": 1765905625513,
    "duration": 88
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/4",
    "scheme": "vscode-terminal",
    "query": "command=tool-31412ed1-44ba-4388-a380-91f6d69d9f75"
  },
  "terminalCommandOutput": {
    "text": "ERROR 1045 (28000): Access denied for user 'ODBC'@'localhost' (using password: NO)\r\n\u001b[91mpython.exe : ScriptBlock should only be specified as a value of the Command \r\nparameter.\r\nAt line:1 char:1\r\n+ D:\\KHDL_cuoiky\\.venv\\Scripts\\python.exe -c \"from pathlib import Path; ...\r\n+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    + CategoryInfo          : InvalidArgument: (:) [], ParameterBindingException      \r\n    + FullyQualifiedErrorId : IncorrectValueForCommandParameter\r\n\u001b[0m\u001b[?1004h",
    "lineCount": 9
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "2d566124-ae05-4d71-8f8f-9f186a60b388",
  "terminalCommandId": "tool-fb721d7c-755b-4b1c-b026-88678efaa1e8",
  "commandLine": {
    "original": "D:\\KHDL_cuoiky\\.venv\\Scripts\\python.exe -c \"from pathlib import Path; lines=Path('app.py').read_text(encoding='utf-8').splitlines(); markers={'timeline_func':'def build_usage_timeline','timeline_plot':'st.plotly_chart(timeline_fig','logs_section':'with st.expander(\\\"Lịch sử tương tác (MySQL)\\\"'}; \nfor name, marker in markers.items():\n    for idx,line in enumerate(lines,1):\n        if marker in line:\n            print(f'{name}:L{idx}')\n            break\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 1,
    "timestamp": 1765905645526,
    "duration": 43
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/4",
    "scheme": "vscode-terminal",
    "query": "command=tool-fb721d7c-755b-4b1c-b026-88678efaa1e8"
  },
  "terminalCommandOutput": {
    "text": "ERROR 1045 (28000): Access denied for user 'ODBC'@'localhost' (using password: NO)\r\n  File \"&lt;string&gt;\", line 1\r\n    from pathlib import Path; lines=Path('app.py').read_text(encoding='utf-8').splitlines(); markers={'timeline_func':'def build_usage_timeline','timeline_plot':'st.plotly_chart(timeline_fig','logs_section':'with st.expander(\" Lịch sử tương tác  \\'};        \r\n                                                                                      \r\n                                                                                      \r\n                                   ^\r\nSyntaxError: unterminated string literal (detected at line 1)\u001b[?1004h",
    "lineCount": 9
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalToolSessionId": "9141f573-8fca-4269-915e-d85a920d8a84",
  "terminalCommandId": "tool-ca5fe1ec-66f6-439b-87e0-e902f227e2fd",
  "commandLine": {
    "original": "Select-String -Path D:\\KHDL_cuoiky\\app.py -Pattern \"def build_usage_timeline\",\"plotly_chart\\(timeline_fig\",\"with st\\.expander\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 0,
    "timestamp": 1765905656769,
    "duration": 53
  },
  "terminalCommandUri": {
    "$mid": 1,
    "path": "/4e26c6ed032fbeb89e2370aeca49597e/4",
    "scheme": "vscode-terminal",
    "query": "command=tool-ca5fe1ec-66f6-439b-87e0-e902f227e2fd"
  },
  "terminalCommandOutput": {
    "text": "\u001b[36m_timeline\"\u001b[90m,\u001b[36m\"plotly_chart\\(timeline_fig\"\u001b[90m,\u001b[36m\"with st\\.expander\"\r\n\r\n\u001b[0mapp.py:316:def build_usage_timeline(logs: list[dict]) -&gt; tuple[pd.DataFrame, Figure \r\n| None]:\r\napp.py:543:        with st.expander(\"Lịch sử tương tác (MySQL)\", expanded=False):     \r\napp.py:549:                    st.plotly_chart(timeline_fig,\r\nuse_container_width=True, config={\"displayModeBar\": False})\r\n\r\n\u001b[?1004h",
    "lineCount": 9
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

**Planning timeline visualization****Designing a usage timeline visualization**

I'm mapping out a plan to build a timeline chart showing usage logs over time using Plotly Express and Streamlit. I'll create a helper function to transform logs into a timeline figure with 30-second spans, add hover details, apply a color palette, and embed it in an expander with a slider-driven log fetch. I want to keep the style consistent and handle cases with no data gracefully.**Adding helper function****Improving timeline dataframe handling and hover display**

I’m working on making the timeline DataFrame column retrieval more robust by using a helper that returns a filled Series with the correct index. I also want to simplify the hover display in the Plotly timeline by switching to `hover_name="hover"` instead of complex `hover_data` with customdata, avoiding manual trace updates. Additionally, I’m planning to sort the timeline ascending and improve integration in the UI with proper data conversions and display logic.**Integrating timeline visualization****Confirming imports and line references****Troubleshooting PowerShell command errors****Searching code using ASCII markers****Preparing final response details**- Bổ sung hàm `build_usage_timeline()` tạo Plotly Timeline từ log MySQL, xử lý thiếu cột/hover text và tô màu theo model để thấy chuỗi thao tác nổi bật `undefined`.
- Thay phần “Lịch sử tương tác” bằng timeline mới: nếu có dữ liệu, hiển thị biểu đồ thời gian + bảng chi tiết, cho phép nắm nhanh user nào đang ưu tiên mô hình nào `undefined`.
- Plotly đã được import cùng `timedelta` để phục vụ phần này `undefined`.

Chưa khởi chạy lại Streamlit; hãy `streamlit run app.py` hoặc nhấn “Rerun” trong UI để trải nghiệm timeline mới.

---

_**User (2025-12-16 17:23Z)**_

Cung cấp bộ điều khiển theme nâng cao (tùy chọn Dark/Lite, chỉnh alpha hybrid) cùng tooltip giải thích mỗi widget; điều này tăng tính kiểm soát và giúp chia sẻ dashboard cho stakeholder không rành kỹ thuật.

---

_**Agent (model copilot/gpt-5.1-codex)**_

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles(theme: str = "Dark") -> None:
    theme_class = "theme-dark" if theme == "Dark" else "theme-light"
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            .theme-light {
                --surface: #f7f8fb;
                --surface-alt: #ffffff;
                --panel: rgba(255,255,255,0.86);
                --panel-solid: #ffffff;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.18);
                --muted: #5f6580;
                --border: rgba(15,23,42,0.08);
            }
            .theme-light body {
                background: linear-gradient(135deg, #fdf7f2 0%, #f1f5ff 60%, #e5eefb 100%);
                color: #1c2439;
            }
            .theme-light [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #ffffff 0%, #f0f4ff 100%);
                color: #1c2439;
                border-right: 1px solid rgba(15,23,42,0.08);
            }
            .theme-light .hero-card {
                background: linear-gradient(120deg, #ffffff 0%, #f1f5ff 60%, #fef2e8 100%);
                color: #101530;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )
    st.markdown(f"<div class='{theme_class}'>", unsafe_allow_html=True)


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


def build_usage_timeline(logs: list[dict]) -> tuple[pd.DataFrame, Figure | None]:
    if not logs:
        return pd.DataFrame(), None

    timeline_df = pd.DataFrame(logs)
    if timeline_df.empty:
        return timeline_df, None

    if "created_at" in timeline_df:
        timeline_df["created_at"] = pd.to_datetime(timeline_df["created_at"])
    else:
        timeline_df["created_at"] = pd.to_datetime(timeline_df.index)

    timeline_df.sort_values("created_at", inplace=True)
    timeline_df["end_at"] = timeline_df["created_at"] + timedelta(minutes=2)

    def _field(name: str, fallback: str = "-") -> pd.Series:
        series = timeline_df.get(name)
        if series is None:
            return pd.Series([fallback] * len(timeline_df), index=timeline_df.index)
        return series.fillna(fallback).astype(str)

    timeline_df["hover"] = (
        "User #" + timeline_df["user_id"].astype(str)
        + " · Model: " + _field("model_used", "?")
        + "<br>Movie: " + _field("movie_id")
        + "<br>Score: " + _field("score_shown")
        + "<br>Action: " + _field("action")
    )

    fig = px.timeline(
        timeline_df,
        x_start="created_at",
        x_end="end_at",
        y="user_id",
        color="model_used",
        hover_name="hover",
        labels={"user_id": "User", "model_used": "Model"},
        color_discrete_sequence=["#ff6b35", "#8aa1ff", "#46d4a5", "#f7b955"],
    )
    fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=60, r=20, t=30, b=20),
        legend_title_text="Thuật toán",
        yaxis=dict(title="User", tickmode="linear"),
        height=320,
    )
    return timeline_df, fig


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")
    inject_styles()

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=0.55)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0)
    model_choice = st.sidebar.selectbox("Model", ["Content-based", "Collaborative (SVD)", "Hybrid"])
    top_k = st.sidebar.slider("Number of recommendations", min_value=5, max_value=20, value=10)
    genre_filter = st.sidebar.text_input("Optional genre filter (e.g., Comedy)")

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = list(fetch_recent_logs(limit=limit))
            if logs:
                log_df, timeline_fig = build_usage_timeline(logs)
                if timeline_fig is not None:
                    st.plotly_chart(timeline_fig, use_container_width=True, config={"displayModeBar": False})
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles(theme: str = "Dark") -> None:
    theme_class = "theme-dark" if theme == "Dark" else "theme-light"
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            .theme-light {
                --surface: #f7f8fb;
                --surface-alt: #ffffff;
                --panel: rgba(255,255,255,0.86);
                --panel-solid: #ffffff;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.18);
                --muted: #5f6580;
                --border: rgba(15,23,42,0.08);
            }
            .theme-light body {
                background: linear-gradient(135deg, #fdf7f2 0%, #f1f5ff 60%, #e5eefb 100%);
                color: #1c2439;
            }
            .theme-light [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #ffffff 0%, #f0f4ff 100%);
                color: #1c2439;
                border-right: 1px solid rgba(15,23,42,0.08);
            }
            .theme-light .hero-card {
                background: linear-gradient(120deg, #ffffff 0%, #f1f5ff 60%, #fef2e8 100%);
                color: #101530;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )
    st.markdown(f"<div class='{theme_class}'>", unsafe_allow_html=True)


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


def build_usage_timeline(logs: list[dict]) -> tuple[pd.DataFrame, Figure | None]:
    if not logs:
        return pd.DataFrame(), None

    timeline_df = pd.DataFrame(logs)
    if timeline_df.empty:
        return timeline_df, None

    if "created_at" in timeline_df:
        timeline_df["created_at"] = pd.to_datetime(timeline_df["created_at"])
    else:
        timeline_df["created_at"] = pd.to_datetime(timeline_df.index)

    timeline_df.sort_values("created_at", inplace=True)
    timeline_df["end_at"] = timeline_df["created_at"] + timedelta(minutes=2)

    def _field(name: str, fallback: str = "-") -> pd.Series:
        series = timeline_df.get(name)
        if series is None:
            return pd.Series([fallback] * len(timeline_df), index=timeline_df.index)
        return series.fillna(fallback).astype(str)

    timeline_df["hover"] = (
        "User #" + timeline_df["user_id"].astype(str)
        + " · Model: " + _field("model_used", "?")
        + "<br>Movie: " + _field("movie_id")
        + "<br>Score: " + _field("score_shown")
        + "<br>Action: " + _field("action")
    )

    fig = px.timeline(
        timeline_df,
        x_start="created_at",
        x_end="end_at",
        y="user_id",
        color="model_used",
        hover_name="hover",
        labels={"user_id": "User", "model_used": "Model"},
        color_discrete_sequence=["#ff6b35", "#8aa1ff", "#46d4a5", "#f7b955"],
    )
    fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=60, r=20, t=30, b=20),
        legend_title_text="Thuật toán",
        yaxis=dict(title="User", tickmode="linear"),
        height=320,
    )
    return timeline_df, fig


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")

    st.sidebar.subheader("Studio")
    theme_choice = st.sidebar.radio("Theme", ["Dark", "Light"], index=0, help="Đổi bảng màu tổng thể của dashboard để phù hợp môi trường trình chiếu.")
    alpha_default = 0.55
    hybrid_alpha = st.sidebar.slider(
        "Hybrid alpha",
        min_value=0.2,
        max_value=0.8,
        value=alpha_default,
        step=0.05,
        help="Điều chỉnh tỷ lệ trọng số giữa collaborative (cao) và content-based (thấp).",
    )
    inject_styles(theme_choice)

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=hybrid_alpha)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0, help="Chọn user thực tế từ MovieLens để xem lịch sử gợi ý cá nhân.")
    model_choice = st.sidebar.selectbox(
        "Model",
        ["Content-based", "Collaborative (SVD)", "Hybrid"],
        help="So sánh nhanh giữa ba chiến lược gợi ý đang triển khai.",
    )
    top_k = st.sidebar.slider(
        "Number of recommendations",
        min_value=5,
        max_value=20,
        value=10,
        help="Quy định số lượng phim xuất hiện trong bảng xếp hạng.",
    )
    genre_filter = st.sidebar.text_input(
        "Optional genre filter (e.g., Comedy)",
        help="Lọc nhanh theo thể loại quan tâm, hỗ trợ viết thường/hoa tự do.",
    )

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = list(fetch_recent_logs(limit=limit))
            if logs:
                log_df, timeline_fig = build_usage_timeline(logs)
                if timeline_fig is not None:
                    st.plotly_chart(timeline_fig, use_container_width=True, config={"displayModeBar": False})
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles(theme: str = "Dark") -> None:
    theme_class = "theme-dark" if theme == "Dark" else "theme-light"
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            .theme-light {
                --surface: #f7f8fb;
                --surface-alt: #ffffff;
                --panel: rgba(255,255,255,0.86);
                --panel-solid: #ffffff;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.18);
                --muted: #5f6580;
                --border: rgba(15,23,42,0.08);
            }
            .theme-light body {
                background: linear-gradient(135deg, #fdf7f2 0%, #f1f5ff 60%, #e5eefb 100%);
                color: #1c2439;
            }
            .theme-light [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #ffffff 0%, #f0f4ff 100%);
                color: #1c2439;
                border-right: 1px solid rgba(15,23,42,0.08);
            }
            .theme-light .hero-card {
                background: linear-gradient(120deg, #ffffff 0%, #f1f5ff 60%, #fef2e8 100%);
                color: #101530;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )
    st.markdown(f"<div class='{theme_class}'>", unsafe_allow_html=True)


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


def build_usage_timeline(logs: list[dict]) -> tuple[pd.DataFrame, Figure | None]:
    if not logs:
        return pd.DataFrame(), None

    timeline_df = pd.DataFrame(logs)
    if timeline_df.empty:
        return timeline_df, None

    if "created_at" in timeline_df:
        timeline_df["created_at"] = pd.to_datetime(timeline_df["created_at"])
    else:
        timeline_df["created_at"] = pd.to_datetime(timeline_df.index)

    timeline_df.sort_values("created_at", inplace=True)
    timeline_df["end_at"] = timeline_df["created_at"] + timedelta(minutes=2)

    def _field(name: str, fallback: str = "-") -> pd.Series:
        series = timeline_df.get(name)
        if series is None:
            return pd.Series([fallback] * len(timeline_df), index=timeline_df.index)
        return series.fillna(fallback).astype(str)

    timeline_df["hover"] = (
        "User #" + timeline_df["user_id"].astype(str)
        + " · Model: " + _field("model_used", "?")
        + "<br>Movie: " + _field("movie_id")
        + "<br>Score: " + _field("score_shown")
        + "<br>Action: " + _field("action")
    )

    fig = px.timeline(
        timeline_df,
        x_start="created_at",
        x_end="end_at",
        y="user_id",
        color="model_used",
        hover_name="hover",
        labels={"user_id": "User", "model_used": "Model"},
        color_discrete_sequence=["#ff6b35", "#8aa1ff", "#46d4a5", "#f7b955"],
    )
    fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=60, r=20, t=30, b=20),
        legend_title_text="Thuật toán",
        yaxis=dict(title="User", tickmode="linear"),
        height=320,
    )
    return timeline_df, fig


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")

    st.sidebar.subheader("Studio")
    theme_choice = st.sidebar.radio("Theme", ["Dark", "Light"], index=0, help="Đổi bảng màu tổng thể của dashboard để phù hợp môi trường trình chiếu.")
    alpha_default = 0.55
    hybrid_alpha = st.sidebar.slider(
        "Hybrid alpha",
        min_value=0.2,
        max_value=0.8,
        value=alpha_default,
        step=0.05,
        help="Điều chỉnh tỷ lệ trọng số giữa collaborative (cao) và content-based (thấp).",
    )
    inject_styles(theme_choice)

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=hybrid_alpha)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0, help="Chọn user thực tế từ MovieLens để xem lịch sử gợi ý cá nhân.")
    model_choice = st.sidebar.selectbox(
        "Model",
        ["Content-based", "Collaborative (SVD)", "Hybrid"],
        help="So sánh nhanh giữa ba chiến lược gợi ý đang triển khai.",
    )
    top_k = st.sidebar.slider(
        "Number of recommendations",
        min_value=5,
        max_value=20,
        value=10,
        help="Quy định số lượng phim xuất hiện trong bảng xếp hạng.",
    )
    genre_filter = st.sidebar.text_input(
        "Optional genre filter (e.g., Comedy)",
        help="Lọc nhanh theo thể loại quan tâm, hỗ trợ viết thường/hoa tự do.",
    )

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = list(fetch_recent_logs(limit=limit))
            if logs:
                log_df, timeline_fig = build_usage_timeline(logs)
                if timeline_fig is not None:
                    st.plotly_chart(timeline_fig, use_container_width=True, config={"displayModeBar": False})
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()
    st.markdown("</div>", unsafe_allow_html=True)

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles(theme: str = "Dark") -> None:
    theme_class = "theme-dark" if theme == "Dark" else "theme-light"
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
            }
            .stApp {
                background: transparent;
            }
            .theme-light {
                --surface: #f7f8fb;
                --surface-alt: #ffffff;
                --panel: rgba(255,255,255,0.86);
                --panel-solid: #ffffff;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.18);
                --muted: #5f6580;
                --border: rgba(15,23,42,0.08);
            }
            .theme-light body {
                background: linear-gradient(135deg, #fdf7f2 0%, #f1f5ff 60%, #e5eefb 100%);
                color: #1c2439;
            }
            .theme-light [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #ffffff 0%, #f0f4ff 100%);
                color: #1c2439;
                border-right: 1px solid rgba(15,23,42,0.08);
            }
            .theme-light .hero-card {
                background: linear-gradient(120deg, #ffffff 0%, #f1f5ff 60%, #fef2e8 100%);
                color: #101530;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )
    st.markdown(f"<div class='{theme_class}'>", unsafe_allow_html=True)


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


def build_usage_timeline(logs: list[dict]) -> tuple[pd.DataFrame, Figure | None]:
    if not logs:
        return pd.DataFrame(), None

    timeline_df = pd.DataFrame(logs)
    if timeline_df.empty:
        return timeline_df, None

    if "created_at" in timeline_df:
        timeline_df["created_at"] = pd.to_datetime(timeline_df["created_at"])
    else:
        timeline_df["created_at"] = pd.to_datetime(timeline_df.index)

    timeline_df.sort_values("created_at", inplace=True)
    timeline_df["end_at"] = timeline_df["created_at"] + timedelta(minutes=2)

    def _field(name: str, fallback: str = "-") -> pd.Series:
        series = timeline_df.get(name)
        if series is None:
            return pd.Series([fallback] * len(timeline_df), index=timeline_df.index)
        return series.fillna(fallback).astype(str)

    timeline_df["hover"] = (
        "User #" + timeline_df["user_id"].astype(str)
        + " · Model: " + _field("model_used", "?")
        + "<br>Movie: " + _field("movie_id")
        + "<br>Score: " + _field("score_shown")
        + "<br>Action: " + _field("action")
    )

    fig = px.timeline(
        timeline_df,
        x_start="created_at",
        x_end="end_at",
        y="user_id",
        color="model_used",
        hover_name="hover",
        labels={"user_id": "User", "model_used": "Model"},
        color_discrete_sequence=["#ff6b35", "#8aa1ff", "#46d4a5", "#f7b955"],
    )
    fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=60, r=20, t=30, b=20),
        legend_title_text="Thuật toán",
        yaxis=dict(title="User", tickmode="linear"),
        height=320,
    )
    return timeline_df, fig


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")

    st.sidebar.subheader("Studio")
    theme_choice = st.sidebar.radio("Theme", ["Dark", "Light"], index=0, help="Đổi bảng màu tổng thể của dashboard để phù hợp môi trường trình chiếu.")
    alpha_default = 0.55
    hybrid_alpha = st.sidebar.slider(
        "Hybrid alpha",
        min_value=0.2,
        max_value=0.8,
        value=alpha_default,
        step=0.05,
        help="Điều chỉnh tỷ lệ trọng số giữa collaborative (cao) và content-based (thấp).",
    )
    inject_styles(theme_choice)

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=hybrid_alpha)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0, help="Chọn user thực tế từ MovieLens để xem lịch sử gợi ý cá nhân.")
    model_choice = st.sidebar.selectbox(
        "Model",
        ["Content-based", "Collaborative (SVD)", "Hybrid"],
        help="So sánh nhanh giữa ba chiến lược gợi ý đang triển khai.",
    )
    top_k = st.sidebar.slider(
        "Number of recommendations",
        min_value=5,
        max_value=20,
        value=10,
        help="Quy định số lượng phim xuất hiện trong bảng xếp hạng.",
    )
    genre_filter = st.sidebar.text_input(
        "Optional genre filter (e.g., Comedy)",
        help="Lọc nhanh theo thể loại quan tâm, hỗ trợ viết thường/hoa tự do.",
    )

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    alpha_phrase = f" · α={hybrid_alpha:.2f}" if model_choice == "Hybrid" else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}{alpha_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = list(fetch_recent_logs(limit=limit))
            if logs:
                log_df, timeline_fig = build_usage_timeline(logs)
                if timeline_fig is not None:
                    st.plotly_chart(timeline_fig, use_container_width=True, config={"displayModeBar": False})
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()
    st.markdown("</div>", unsafe_allow_html=True)

```


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalCommandId": "tool-ae9b81fa-d13f-44d2-a439-014372fd4428",
  "commandLine": {
    "original": "Select-String -Path D:\\KHDL_cuoiky\\app.py -Pattern \"theme_choice\",\"Hybrid alpha\",\"help=\",\"alpha_phrase\""
  },
  "language": "pwsh",
  "terminalCommandState": {
    "exitCode": 0,
    "timestamp": 1765905820270,
    "duration": 116
  },
  "terminalCommandOutput": {
    "text": "\r\napp.py:404:    \r\ntheme_choice = st.sidebar \r\n.radio(\"Theme\", [\"Dark\",  \r\n\"Light\"], index=0,        \r\nhelp=\"Đổi bảng màu tổng   \r\nthể của dashboard để phù  \r\nhợp môi trường trình      \r\nchiếu.\")\r\napp.py:407:\r\n\"Hybrid alpha\",\r\napp.py:412:\r\nhelp=\"Điều chỉnh tỷ lệ    \r\ntrọng số giữa\r\ncollaborative (cao) và    \r\ncontent-based (thấp).\",   \r\napp.py:414:    inject_sty \r\nles(theme_choice)\r\napp.py:421:    user_id =  \r\nst.sidebar.selectbox(\"Use \r\nr ID\", user_ids,\r\nindex=0, help=\"Chọn user  \r\nthực tế từ MovieLens để   \r\nxem lịch sử gợi ý cá      \r\nnhân.\")\r\napp.py:425:\r\nhelp=\"So sánh nhanh giữa  \r\nba chiến lược gợi ý đang  \r\ntriển khai.\",\r\napp.py:432:\r\nhelp=\"Quy định số lượng   \r\nphim xuất hiện trong      \r\nbảng xếp hạng.\",\r\napp.py:436:\r\nhelp=\"Lọc nhanh theo thể  \r\nloại quan tâm, hỗ trợ     \r\nviết thường/hoa tự do.\",  \r\napp.py:549:\r\nalpha_phrase = f\" ·       \r\nα={hybrid_alpha:.2f}\" if  \r\nmodel_choice == \"Hybrid\"  \r\nelse \"\"\r\napp.py:550:\r\ncontext_line = f\"User     \r\n#{user_id} · Top {top_k}{ \r\ngenre_phrase}{alpha_phras \r\ne}\"\r\napp.py:576:\r\n\"Lưu thủ công\",\r\nhelp=\"Nhấn khi muốn ép    \r\nghi lại log cho cấu hình  \r\nnày\"\r\n\r\n\u001b[?1004h",
    "lineCount": 54
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

**Managing Streamlit markdown wrapping**

I’m figuring out how to properly wrap the entire app in a theme using st.markdown, ensuring the opening and closing tags execute once per run without breaking Streamlit’s re-run behavior. I’ll update the context line to mention “α” only when the Hybrid model is selected and check if st.caption can reflect theme changes.**Checking script execution and slider behavior****Verifying HTML div tags and Streamlit reruns**- Sidebar bổ sung cụm “Studio”: chọn Theme Dark/Light và slider `Hybrid alpha` kèm tooltip giải thích, đồng thời tất cả widget điều hướng cũng có help text giúp stakeholder hiểu từng tuỳ chọn mà không cần kiến thức kỹ thuật `undefined`.
- `inject_styles()` giờ nhận `theme_choice`, dựng hai bảng màu (dark gradient và light airy) và bao toàn bộ app trong wrapper `<div class="theme-…">`; bảng dữ liệu, hero card, sidebar… tự đổi palette theo lựa chọn `undefined`.
- Hybrid recommender dùng alpha động, đồng thời thẻ “Model Focus” hiển thị thêm `α=…` khi chọn chế độ hybrid để minh bạch cấu hình `undefined`.
- Khi script chạy, closing tag `</div>` được render sau `main()` để tránh rò rỉ DOM `undefined`.

Nhớ khởi chạy lại `streamlit run app.py` (hoặc nhấn Rerun) để trải nghiệm theme switcher và điều chỉnh alpha realtime.

---

_**User (2025-12-16 17:24Z)**_

chạy lại dự án cho tôi

---

_**Agent (model copilot/gpt-5.1-codex)**_

<tool-use data-tool-type="unknown" data-tool-name="run_in_terminal">
<details>
<summary>Tool use: **run_in_terminal**</summary>


Parameters:

```json
{
  "kind": "terminal",
  "terminalCommandId": "tool-20f2999b-0c65-4f9d-afe1-005cf93c9cc0",
  "commandLine": {
    "original": "cd /d D:\\KHDL_cuoiky; D:/KHDL_cuoiky/.venv/Scripts/python.exe -m streamlit run app.py",
    "toolEdited": "D:/KHDL_cuoiky/.venv/Scripts/python.exe -m streamlit run app.py"
  },
  "language": "pwsh",
  "terminalCommandState": {
    "timestamp": 1765905865608
  },
  "terminalTheme": {
    "background": "#181818",
    "foreground": "#cccccc"
  }
}
```
Additional data:

```json
{
  "vscodeToolId": "run_in_terminal",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Using \"Run in Terminal\"",
  "isConfirmed": {
    "type": 4
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="get_terminal_output">
<details>
<summary>Tool use: **get_terminal_output**</summary>

Additional data:

```json
{
  "vscodeToolId": "get_terminal_output",
  "isHidden": false
}
```
Result:

```json
{
  "invocationMessage": "Checking background terminal output",
  "isConfirmed": {
    "type": 1
  },
  "content": "",
  "textEditContent": "",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

- Streamlit server is running again at http://localhost:8501 (also accessible via the network URL printed).  
- Streamlit warns that `use_container_width` is deprecated; next time we touch the code we should swap remaining instances for `width='stretch'`/`'content'`.  
- Let me know if you need help updating those warnings or if you want me to stop the server when you’re done.

---

_**User (2025-12-16 17:29Z)**_

đổi hết chữ sang màu sáng và tạo thêm cho tôi 2 biểu đồ nữa

---

_**Agent (model copilot/gpt-5.1-codex)**_

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles(theme: str = "Dark") -> None:
    theme_class = "theme-dark" if theme == "Dark" else "theme-light"
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
                color: #f6f8ff;
            }
            .stApp {
                background: transparent;
            }
            .stApp, .stApp * {
                color: #f4f7ff;
            }
            .theme-light {
                --surface: #f7f8fb;
                --surface-alt: #ffffff;
                --panel: rgba(255,255,255,0.86);
                --panel-solid: #ffffff;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.18);
                --muted: #5f6580;
                --border: rgba(15,23,42,0.08);
            }
            .theme-light body {
                background: linear-gradient(135deg, #fdf7f2 0%, #f1f5ff 60%, #e5eefb 100%);
                color: #1c2439;
            }
            .theme-light .stApp,
            .theme-light .stApp * {
                color: #1c2439;
            }
            .theme-light [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #ffffff 0%, #f0f4ff 100%);
                color: #1c2439;
                border-right: 1px solid rgba(15,23,42,0.08);
            }
            .theme-light .hero-card {
                background: linear-gradient(120deg, #ffffff 0%, #f1f5ff 60%, #fef2e8 100%);
                color: #101530;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: var(--muted);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )
    st.markdown(f"<div class='{theme_class}'>", unsafe_allow_html=True)


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


def build_usage_timeline(logs: list[dict]) -> tuple[pd.DataFrame, Figure | None]:
    if not logs:
        return pd.DataFrame(), None

    timeline_df = pd.DataFrame(logs)
    if timeline_df.empty:
        return timeline_df, None

    if "created_at" in timeline_df:
        timeline_df["created_at"] = pd.to_datetime(timeline_df["created_at"])
    else:
        timeline_df["created_at"] = pd.to_datetime(timeline_df.index)

    timeline_df.sort_values("created_at", inplace=True)
    timeline_df["end_at"] = timeline_df["created_at"] + timedelta(minutes=2)

    def _field(name: str, fallback: str = "-") -> pd.Series:
        series = timeline_df.get(name)
        if series is None:
            return pd.Series([fallback] * len(timeline_df), index=timeline_df.index)
        return series.fillna(fallback).astype(str)

    timeline_df["hover"] = (
        "User #" + timeline_df["user_id"].astype(str)
        + " · Model: " + _field("model_used", "?")
        + "<br>Movie: " + _field("movie_id")
        + "<br>Score: " + _field("score_shown")
        + "<br>Action: " + _field("action")
    )

    fig = px.timeline(
        timeline_df,
        x_start="created_at",
        x_end="end_at",
        y="user_id",
        color="model_used",
        hover_name="hover",
        labels={"user_id": "User", "model_used": "Model"},
        color_discrete_sequence=["#ff6b35", "#8aa1ff", "#46d4a5", "#f7b955"],
    )
    fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=60, r=20, t=30, b=20),
        legend_title_text="Thuật toán",
        yaxis=dict(title="User", tickmode="linear"),
        height=320,
    )
    return timeline_df, fig


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")

    st.sidebar.subheader("Studio")
    theme_choice = st.sidebar.radio("Theme", ["Dark", "Light"], index=0, help="Đổi bảng màu tổng thể của dashboard để phù hợp môi trường trình chiếu.")
    alpha_default = 0.55
    hybrid_alpha = st.sidebar.slider(
        "Hybrid alpha",
        min_value=0.2,
        max_value=0.8,
        value=alpha_default,
        step=0.05,
        help="Điều chỉnh tỷ lệ trọng số giữa collaborative (cao) và content-based (thấp).",
    )
    inject_styles(theme_choice)

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=hybrid_alpha)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0, help="Chọn user thực tế từ MovieLens để xem lịch sử gợi ý cá nhân.")
    model_choice = st.sidebar.selectbox(
        "Model",
        ["Content-based", "Collaborative (SVD)", "Hybrid"],
        help="So sánh nhanh giữa ba chiến lược gợi ý đang triển khai.",
    )
    top_k = st.sidebar.slider(
        "Number of recommendations",
        min_value=5,
        max_value=20,
        value=10,
        help="Quy định số lượng phim xuất hiện trong bảng xếp hạng.",
    )
    genre_filter = st.sidebar.text_input(
        "Optional genre filter (e.g., Comedy)",
        help="Lọc nhanh theo thể loại quan tâm, hỗ trợ viết thường/hoa tự do.",
    )

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    alpha_phrase = f" · α={hybrid_alpha:.2f}" if model_choice == "Hybrid" else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}{alpha_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = list(fetch_recent_logs(limit=limit))
            if logs:
                log_df, timeline_fig = build_usage_timeline(logs)
                if timeline_fig is not None:
                    st.plotly_chart(timeline_fig, use_container_width=True, config={"displayModeBar": False})
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()
    st.markdown("</div>", unsafe_allow_html=True)

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles(theme: str = "Dark") -> None:
    theme_class = "theme-dark" if theme == "Dark" else "theme-light"
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
                color: #f6f8ff;
            }
            .stApp {
                background: transparent;
            }
            .stApp, .stApp * {
                color: #f4f7ff;
            }
            .theme-light {
                --surface: #f7f8fb;
                --surface-alt: #ffffff;
                --panel: rgba(255,255,255,0.86);
                --panel-solid: #ffffff;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.18);
                --muted: #5f6580;
                --border: rgba(15,23,42,0.08);
            }
            .theme-light body {
                background: linear-gradient(135deg, #fdf7f2 0%, #f1f5ff 60%, #e5eefb 100%);
                color: #1c2439;
            }
            .theme-light .stApp,
            .theme-light .stApp * {
                color: #1c2439;
            }
            .theme-light [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #ffffff 0%, #f0f4ff 100%);
                color: #1c2439;
                border-right: 1px solid rgba(15,23,42,0.08);
            }
            .theme-light .hero-card {
                background: linear-gradient(120deg, #ffffff 0%, #f1f5ff 60%, #fef2e8 100%);
                color: #101530;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: rgba(255,255,255,0.85);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #e3e8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )
    st.markdown(f"<div class='{theme_class}'>", unsafe_allow_html=True)


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


def build_usage_timeline(logs: list[dict]) -> tuple[pd.DataFrame, Figure | None]:
    if not logs:
        return pd.DataFrame(), None

    timeline_df = pd.DataFrame(logs)
    if timeline_df.empty:
        return timeline_df, None

    if "created_at" in timeline_df:
        timeline_df["created_at"] = pd.to_datetime(timeline_df["created_at"])
    else:
        timeline_df["created_at"] = pd.to_datetime(timeline_df.index)

    timeline_df.sort_values("created_at", inplace=True)
    timeline_df["end_at"] = timeline_df["created_at"] + timedelta(minutes=2)

    def _field(name: str, fallback: str = "-") -> pd.Series:
        series = timeline_df.get(name)
        if series is None:
            return pd.Series([fallback] * len(timeline_df), index=timeline_df.index)
        return series.fillna(fallback).astype(str)

    timeline_df["hover"] = (
        "User #" + timeline_df["user_id"].astype(str)
        + " · Model: " + _field("model_used", "?")
        + "<br>Movie: " + _field("movie_id")
        + "<br>Score: " + _field("score_shown")
        + "<br>Action: " + _field("action")
    )

    fig = px.timeline(
        timeline_df,
        x_start="created_at",
        x_end="end_at",
        y="user_id",
        color="model_used",
        hover_name="hover",
        labels={"user_id": "User", "model_used": "Model"},
        color_discrete_sequence=["#ff6b35", "#8aa1ff", "#46d4a5", "#f7b955"],
    )
    fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=60, r=20, t=30, b=20),
        legend_title_text="Thuật toán",
        yaxis=dict(title="User", tickmode="linear"),
        height=320,
    )
    return timeline_df, fig


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")

    st.sidebar.subheader("Studio")
    theme_choice = st.sidebar.radio("Theme", ["Dark", "Light"], index=0, help="Đổi bảng màu tổng thể của dashboard để phù hợp môi trường trình chiếu.")
    alpha_default = 0.55
    hybrid_alpha = st.sidebar.slider(
        "Hybrid alpha",
        min_value=0.2,
        max_value=0.8,
        value=alpha_default,
        step=0.05,
        help="Điều chỉnh tỷ lệ trọng số giữa collaborative (cao) và content-based (thấp).",
    )
    inject_styles(theme_choice)

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=hybrid_alpha)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0, help="Chọn user thực tế từ MovieLens để xem lịch sử gợi ý cá nhân.")
    model_choice = st.sidebar.selectbox(
        "Model",
        ["Content-based", "Collaborative (SVD)", "Hybrid"],
        help="So sánh nhanh giữa ba chiến lược gợi ý đang triển khai.",
    )
    top_k = st.sidebar.slider(
        "Number of recommendations",
        min_value=5,
        max_value=20,
        value=10,
        help="Quy định số lượng phim xuất hiện trong bảng xếp hạng.",
    )
    genre_filter = st.sidebar.text_input(
        "Optional genre filter (e.g., Comedy)",
        help="Lọc nhanh theo thể loại quan tâm, hỗ trợ viết thường/hoa tự do.",
    )

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    alpha_phrase = f" · α={hybrid_alpha:.2f}" if model_choice == "Hybrid" else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}{alpha_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = list(fetch_recent_logs(limit=limit))
            if logs:
                log_df, timeline_fig = build_usage_timeline(logs)
                if timeline_fig is not None:
                    st.plotly_chart(timeline_fig, use_container_width=True, config={"displayModeBar": False})
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()
    st.markdown("</div>", unsafe_allow_html=True)

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles(theme: str = "Dark") -> None:
    theme_class = "theme-dark" if theme == "Dark" else "theme-light"
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
                color: #f6f8ff;
            }
            .stApp {
                background: transparent;
            }
            .stApp, .stApp * {
                color: #f4f7ff;
            }
            .theme-light {
                --surface: #f7f8fb;
                --surface-alt: #ffffff;
                --panel: rgba(255,255,255,0.86);
                --panel-solid: #ffffff;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.18);
                --muted: #5f6580;
                --border: rgba(15,23,42,0.08);
            }
            .theme-light body {
                background: linear-gradient(135deg, #fdf7f2 0%, #f1f5ff 60%, #e5eefb 100%);
                color: #1c2439;
            }
            .theme-light .stApp,
            .theme-light .stApp * {
                color: #1c2439;
            }
            .theme-light [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #ffffff 0%, #f0f4ff 100%);
                color: #1c2439;
                border-right: 1px solid rgba(15,23,42,0.08);
            }
            .theme-light .hero-card {
                background: linear-gradient(120deg, #ffffff 0%, #f1f5ff 60%, #fef2e8 100%);
                color: #101530;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: rgba(255,255,255,0.85);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #f6f8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )
    st.markdown(f"<div class='{theme_class}'>", unsafe_allow_html=True)


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


def build_usage_timeline(logs: list[dict]) -> tuple[pd.DataFrame, Figure | None]:
    if not logs:
        return pd.DataFrame(), None

    timeline_df = pd.DataFrame(logs)
    if timeline_df.empty:
        return timeline_df, None

    if "created_at" in timeline_df:
        timeline_df["created_at"] = pd.to_datetime(timeline_df["created_at"])
    else:
        timeline_df["created_at"] = pd.to_datetime(timeline_df.index)

    timeline_df.sort_values("created_at", inplace=True)
    timeline_df["end_at"] = timeline_df["created_at"] + timedelta(minutes=2)

    def _field(name: str, fallback: str = "-") -> pd.Series:
        series = timeline_df.get(name)
        if series is None:
            return pd.Series([fallback] * len(timeline_df), index=timeline_df.index)
        return series.fillna(fallback).astype(str)

    timeline_df["hover"] = (
        "User #" + timeline_df["user_id"].astype(str)
        + " · Model: " + _field("model_used", "?")
        + "<br>Movie: " + _field("movie_id")
        + "<br>Score: " + _field("score_shown")
        + "<br>Action: " + _field("action")
    )

    fig = px.timeline(
        timeline_df,
        x_start="created_at",
        x_end="end_at",
        y="user_id",
        color="model_used",
        hover_name="hover",
        labels={"user_id": "User", "model_used": "Model"},
        color_discrete_sequence=["#ff6b35", "#8aa1ff", "#46d4a5", "#f7b955"],
    )
    fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=60, r=20, t=30, b=20),
        legend_title_text="Thuật toán",
        yaxis=dict(title="User", tickmode="linear"),
        height=320,
    )
    return timeline_df, fig


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")

    st.sidebar.subheader("Studio")
    theme_choice = st.sidebar.radio("Theme", ["Dark", "Light"], index=0, help="Đổi bảng màu tổng thể của dashboard để phù hợp môi trường trình chiếu.")
    alpha_default = 0.55
    hybrid_alpha = st.sidebar.slider(
        "Hybrid alpha",
        min_value=0.2,
        max_value=0.8,
        value=alpha_default,
        step=0.05,
        help="Điều chỉnh tỷ lệ trọng số giữa collaborative (cao) và content-based (thấp).",
    )
    inject_styles(theme_choice)

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=hybrid_alpha)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0, help="Chọn user thực tế từ MovieLens để xem lịch sử gợi ý cá nhân.")
    model_choice = st.sidebar.selectbox(
        "Model",
        ["Content-based", "Collaborative (SVD)", "Hybrid"],
        help="So sánh nhanh giữa ba chiến lược gợi ý đang triển khai.",
    )
    top_k = st.sidebar.slider(
        "Number of recommendations",
        min_value=5,
        max_value=20,
        value=10,
        help="Quy định số lượng phim xuất hiện trong bảng xếp hạng.",
    )
    genre_filter = st.sidebar.text_input(
        "Optional genre filter (e.g., Comedy)",
        help="Lọc nhanh theo thể loại quan tâm, hỗ trợ viết thường/hoa tự do.",
    )

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    alpha_phrase = f" · α={hybrid_alpha:.2f}" if model_choice == "Hybrid" else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}{alpha_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = list(fetch_recent_logs(limit=limit))
            if logs:
                log_df, timeline_fig = build_usage_timeline(logs)
                if timeline_fig is not None:
                    st.plotly_chart(timeline_fig, use_container_width=True, config={"displayModeBar": False})
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()
    st.markdown("</div>", unsafe_allow_html=True)

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles(theme: str = "Dark") -> None:
    theme_class = "theme-dark" if theme == "Dark" else "theme-light"
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
                color: #f6f8ff;
            }
            .stApp {
                background: transparent;
            }
            .stApp, .stApp * {
                color: #f4f7ff;
            }
            .theme-light {
                --surface: #f7f8fb;
                --surface-alt: #ffffff;
                --panel: rgba(255,255,255,0.86);
                --panel-solid: #ffffff;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.18);
                --muted: #5f6580;
                --border: rgba(15,23,42,0.08);
            }
            .theme-light body {
                background: linear-gradient(135deg, #fdf7f2 0%, #f1f5ff 60%, #e5eefb 100%);
                color: #1c2439;
            }
            .theme-light .stApp,
            .theme-light .stApp * {
                color: #1c2439;
            }
            .theme-light [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #ffffff 0%, #f0f4ff 100%);
                color: #1c2439;
                border-right: 1px solid rgba(15,23,42,0.08);
            }
            .theme-light .hero-card {
                background: linear-gradient(120deg, #ffffff 0%, #f1f5ff 60%, #fef2e8 100%);
                color: #101530;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: rgba(255,255,255,0.85);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #f6f8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )
    st.markdown(f"<div class='{theme_class}'>", unsafe_allow_html=True)


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


def build_usage_timeline(logs: list[dict]) -> tuple[pd.DataFrame, Figure | None]:
    if not logs:
        return pd.DataFrame(), None

    timeline_df = pd.DataFrame(logs)
    if timeline_df.empty:
        return timeline_df, None

    if "created_at" in timeline_df:
        timeline_df["created_at"] = pd.to_datetime(timeline_df["created_at"])
    else:
        timeline_df["created_at"] = pd.to_datetime(timeline_df.index)

    timeline_df.sort_values("created_at", inplace=True)
    timeline_df["end_at"] = timeline_df["created_at"] + timedelta(minutes=2)

    def _field(name: str, fallback: str = "-") -> pd.Series:
        series = timeline_df.get(name)
        if series is None:
            return pd.Series([fallback] * len(timeline_df), index=timeline_df.index)
        return series.fillna(fallback).astype(str)

    timeline_df["hover"] = (
        "User #" + timeline_df["user_id"].astype(str)
        + " · Model: " + _field("model_used", "?")
        + "<br>Movie: " + _field("movie_id")
        + "<br>Score: " + _field("score_shown")
        + "<br>Action: " + _field("action")
    )

    fig = px.timeline(
        timeline_df,
        x_start="created_at",
        x_end="end_at",
        y="user_id",
        color="model_used",
        hover_name="hover",
        labels={"user_id": "User", "model_used": "Model"},
        color_discrete_sequence=["#ff6b35", "#8aa1ff", "#46d4a5", "#f7b955"],
    )
    fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=60, r=20, t=30, b=20),
        legend_title_text="Thuật toán",
        yaxis=dict(title="User", tickmode="linear"),
        height=320,
    )
    return timeline_df, fig


def build_catalogue_figures(ratings: pd.DataFrame, item_df: pd.DataFrame) -> tuple[Figure, Figure, str, str]:
    agg = (
        ratings.groupby("movieId")["rating"].agg(["count", "mean"]).reset_index()
        .rename(columns={"count": "rating_count", "mean": "avg_rating"})
        .merge(item_df[["movieId", "clean_title", "genres"]], on="movieId", how="left")
    )

    top_popular = agg.sort_values("rating_count", ascending=False).head(8)
    scatter_source = agg[agg["rating_count"] >= 10].copy()
    if len(scatter_source) > 400:
        scatter_source = scatter_source.nlargest(400, "rating_count")

    pop_fig = px.bar(
        top_popular,
        x="rating_count",
        y="clean_title",
        orientation="h",
        labels={"rating_count": "Số lượt", "clean_title": "Phim"},
        color_discrete_sequence=["#ffd166"],
    )
    pop_fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=120, r=20, t=10, b=10),
        yaxis=dict(categoryorder="total ascending"),
    )

    scatter_fig = px.scatter(
        scatter_source,
        x="rating_count",
        y="avg_rating",
        size="avg_rating",
        color="avg_rating",
        hover_data={"clean_title": True, "genres": True},
        color_continuous_scale="Sunset",
        labels={"rating_count": "Số lượt", "avg_rating": "Điểm trung bình"},
    )
    scatter_fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=10, r=10, t=10, b=10),
    )

    return pop_fig, scatter_fig, "Top phim được đánh giá nhiều nhất", "Mối quan hệ lượt đánh giá vs. điểm"


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")

    st.sidebar.subheader("Studio")
    theme_choice = st.sidebar.radio("Theme", ["Dark", "Light"], index=0, help="Đổi bảng màu tổng thể của dashboard để phù hợp môi trường trình chiếu.")
    alpha_default = 0.55
    hybrid_alpha = st.sidebar.slider(
        "Hybrid alpha",
        min_value=0.2,
        max_value=0.8,
        value=alpha_default,
        step=0.05,
        help="Điều chỉnh tỷ lệ trọng số giữa collaborative (cao) và content-based (thấp).",
    )
    inject_styles(theme_choice)

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=hybrid_alpha)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0, help="Chọn user thực tế từ MovieLens để xem lịch sử gợi ý cá nhân.")
    model_choice = st.sidebar.selectbox(
        "Model",
        ["Content-based", "Collaborative (SVD)", "Hybrid"],
        help="So sánh nhanh giữa ba chiến lược gợi ý đang triển khai.",
    )
    top_k = st.sidebar.slider(
        "Number of recommendations",
        min_value=5,
        max_value=20,
        value=10,
        help="Quy định số lượng phim xuất hiện trong bảng xếp hạng.",
    )
    genre_filter = st.sidebar.text_input(
        "Optional genre filter (e.g., Comedy)",
        help="Lọc nhanh theo thể loại quan tâm, hỗ trợ viết thường/hoa tự do.",
    )

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    alpha_phrase = f" · α={hybrid_alpha:.2f}" if model_choice == "Hybrid" else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}{alpha_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = list(fetch_recent_logs(limit=limit))
            if logs:
                log_df, timeline_fig = build_usage_timeline(logs)
                if timeline_fig is not None:
                    st.plotly_chart(timeline_fig, use_container_width=True, config={"displayModeBar": False})
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()
    st.markdown("</div>", unsafe_allow_html=True)

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles(theme: str = "Dark") -> None:
    theme_class = "theme-dark" if theme == "Dark" else "theme-light"
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
                color: #f6f8ff;
            }
            .stApp {
                background: transparent;
            }
            .stApp, .stApp * {
                color: #f4f7ff;
            }
            .theme-light {
                --surface: #f7f8fb;
                --surface-alt: #ffffff;
                --panel: rgba(255,255,255,0.86);
                --panel-solid: #ffffff;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.18);
                --muted: #5f6580;
                --border: rgba(15,23,42,0.08);
            }
            .theme-light body {
                background: linear-gradient(135deg, #fdf7f2 0%, #f1f5ff 60%, #e5eefb 100%);
                color: #1c2439;
            }
            .theme-light .stApp,
            .theme-light .stApp * {
                color: #1c2439;
            }
            .theme-light [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #ffffff 0%, #f0f4ff 100%);
                color: #1c2439;
                border-right: 1px solid rgba(15,23,42,0.08);
            }
            .theme-light .hero-card {
                background: linear-gradient(120deg, #ffffff 0%, #f1f5ff 60%, #fef2e8 100%);
                color: #101530;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: rgba(255,255,255,0.85);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #f6f8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )
    st.markdown(f"<div class='{theme_class}'>", unsafe_allow_html=True)


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


def build_usage_timeline(logs: list[dict]) -> tuple[pd.DataFrame, Figure | None]:
    if not logs:
        return pd.DataFrame(), None

    timeline_df = pd.DataFrame(logs)
    if timeline_df.empty:
        return timeline_df, None

    if "created_at" in timeline_df:
        timeline_df["created_at"] = pd.to_datetime(timeline_df["created_at"])
    else:
        timeline_df["created_at"] = pd.to_datetime(timeline_df.index)

    timeline_df.sort_values("created_at", inplace=True)
    timeline_df["end_at"] = timeline_df["created_at"] + timedelta(minutes=2)

    def _field(name: str, fallback: str = "-") -> pd.Series:
        series = timeline_df.get(name)
        if series is None:
            return pd.Series([fallback] * len(timeline_df), index=timeline_df.index)
        return series.fillna(fallback).astype(str)

    timeline_df["hover"] = (
        "User #" + timeline_df["user_id"].astype(str)
        + " · Model: " + _field("model_used", "?")
        + "<br>Movie: " + _field("movie_id")
        + "<br>Score: " + _field("score_shown")
        + "<br>Action: " + _field("action")
    )

    fig = px.timeline(
        timeline_df,
        x_start="created_at",
        x_end="end_at",
        y="user_id",
        color="model_used",
        hover_name="hover",
        labels={"user_id": "User", "model_used": "Model"},
        color_discrete_sequence=["#ff6b35", "#8aa1ff", "#46d4a5", "#f7b955"],
    )
    fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=60, r=20, t=30, b=20),
        legend_title_text="Thuật toán",
        yaxis=dict(title="User", tickmode="linear"),
        height=320,
    )
    return timeline_df, fig


def build_catalogue_figures(ratings: pd.DataFrame, item_df: pd.DataFrame) -> tuple[Figure, Figure, str, str]:
    agg = (
        ratings.groupby("movieId")["rating"].agg(["count", "mean"]).reset_index()
        .rename(columns={"count": "rating_count", "mean": "avg_rating"})
        .merge(item_df[["movieId", "clean_title", "genres"]], on="movieId", how="left")
    )

    top_popular = agg.sort_values("rating_count", ascending=False).head(8)
    scatter_source = agg[agg["rating_count"] >= 10].copy()
    if len(scatter_source) > 400:
        scatter_source = scatter_source.nlargest(400, "rating_count")

    pop_fig = px.bar(
        top_popular,
        x="rating_count",
        y="clean_title",
        orientation="h",
        labels={"rating_count": "Số lượt", "clean_title": "Phim"},
        color_discrete_sequence=["#ffd166"],
    )
    pop_fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=120, r=20, t=10, b=10),
        yaxis=dict(categoryorder="total ascending"),
    )

    scatter_fig = px.scatter(
        scatter_source,
        x="rating_count",
        y="avg_rating",
        size="avg_rating",
        color="avg_rating",
        hover_data={"clean_title": True, "genres": True},
        color_continuous_scale="Sunset",
        labels={"rating_count": "Số lượt", "avg_rating": "Điểm trung bình"},
    )
    scatter_fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=10, r=10, t=10, b=10),
    )

    return pop_fig, scatter_fig, "Top phim được đánh giá nhiều nhất", "Mối quan hệ lượt đánh giá vs. điểm"


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")

    st.sidebar.subheader("Studio")
    theme_choice = st.sidebar.radio("Theme", ["Dark", "Light"], index=0, help="Đổi bảng màu tổng thể của dashboard để phù hợp môi trường trình chiếu.")
    alpha_default = 0.55
    hybrid_alpha = st.sidebar.slider(
        "Hybrid alpha",
        min_value=0.2,
        max_value=0.8,
        value=alpha_default,
        step=0.05,
        help="Điều chỉnh tỷ lệ trọng số giữa collaborative (cao) và content-based (thấp).",
    )
    inject_styles(theme_choice)

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=hybrid_alpha)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0, help="Chọn user thực tế từ MovieLens để xem lịch sử gợi ý cá nhân.")
    model_choice = st.sidebar.selectbox(
        "Model",
        ["Content-based", "Collaborative (SVD)", "Hybrid"],
        help="So sánh nhanh giữa ba chiến lược gợi ý đang triển khai.",
    )
    top_k = st.sidebar.slider(
        "Number of recommendations",
        min_value=5,
        max_value=20,
        value=10,
        help="Quy định số lượng phim xuất hiện trong bảng xếp hạng.",
    )
    genre_filter = st.sidebar.text_input(
        "Optional genre filter (e.g., Comedy)",
        help="Lọc nhanh theo thể loại quan tâm, hỗ trợ viết thường/hoa tự do.",
    )

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    pop_fig, scatter_fig, pop_label, scatter_label = build_catalogue_figures(ratings, item_df)
    global_col1, global_col2 = st.columns(2, gap="large")
    with global_col1:
        st.markdown(f"#### {pop_label}")
        st.plotly_chart(pop_fig, use_container_width=True, config={"displayModeBar": False})
    with global_col2:
        st.markdown(f"#### {scatter_label}")
        st.plotly_chart(scatter_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    alpha_phrase = f" · α={hybrid_alpha:.2f}" if model_choice == "Hybrid" else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}{alpha_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = list(fetch_recent_logs(limit=limit))
            if logs:
                log_df, timeline_fig = build_usage_timeline(logs)
                if timeline_fig is not None:
                    st.plotly_chart(timeline_fig, use_container_width=True, config={"displayModeBar": False})
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()
    st.markdown("</div>", unsafe_allow_html=True)

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

```python
from __future__ import annotations

from pathlib import Path
from datetime import timedelta

import joblib
import pandas as pd
import plotly.express as px
from plotly.graph_objs import Figure
import streamlit as st

from src.recommender import ContentBasedRecommender, HybridRecommender, MatrixFactorizationRecommender, load_models
from src.telemetry import fetch_recent_logs, log_recommendations, telemetry_available

ARTIFACT_DIR = Path("models/artifacts")


@st.cache_resource
def get_models():
    if not (ARTIFACT_DIR / "content_model.joblib").exists():
        st.error("Artifacts not found. Please run scripts/train_models.py first.")
        st.stop()
    content_model, collab_model, feature_store = load_models(ARTIFACT_DIR)
    item_df = joblib.load(ARTIFACT_DIR / "item_df.joblib")
    ratings = joblib.load(ARTIFACT_DIR / "ratings.joblib")
    return content_model, collab_model, feature_store, item_df, ratings


def inject_styles(theme: str = "Dark") -> None:
    theme_class = "theme-dark" if theme == "Dark" else "theme-light"
    st.markdown(
        """
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Clash+Display:wght@500;600&family=Source+Code+Pro:wght@500&display=swap');
            :root {
                --surface: #050912;
                --surface-alt: #0a1226;
                --panel: rgba(15,23,42,0.78);
                --panel-solid: #141b2f;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.15);
                --muted: #9aa4c3;
                --border: rgba(255,255,255,0.12);
            }
            body {
                font-family: 'Space Grotesk', sans-serif;
                background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.06), transparent 42%),
                            radial-gradient(circle at 80% 0%, rgba(255,107,53,0.12), transparent 45%),
                            var(--surface);
                color: #f6f8ff;
            }
            .stApp {
                background: transparent;
            }
            .stApp, .stApp * {
                color: #f4f7ff;
            }
            .theme-light {
                --surface: #f7f8fb;
                --surface-alt: #ffffff;
                --panel: rgba(255,255,255,0.86);
                --panel-solid: #ffffff;
                --accent: #ff6b35;
                --accent-soft: rgba(255,107,53,0.18);
                --muted: #5f6580;
                --border: rgba(15,23,42,0.08);
            }
            .theme-light body {
                background: linear-gradient(135deg, #fdf7f2 0%, #f1f5ff 60%, #e5eefb 100%);
                color: #1c2439;
            }
            .theme-light .stApp,
            .theme-light .stApp * {
                color: #1c2439;
            }
            .theme-light [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #ffffff 0%, #f0f4ff 100%);
                color: #1c2439;
                border-right: 1px solid rgba(15,23,42,0.08);
            }
            .theme-light .hero-card {
                background: linear-gradient(120deg, #ffffff 0%, #f1f5ff 60%, #fef2e8 100%);
                color: #101530;
            }
            h1, h2, .stat-value {
                font-family: 'Clash Display', 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] {
                background: linear-gradient(180deg, #040812 0%, #0a1630 100%);
                color: #e8edff;
                border-right: 1px solid rgba(255,255,255,0.08);
            }
            [data-testid="stSidebar"] * {
                font-family: 'Space Grotesk', sans-serif;
            }
            [data-testid="stSidebar"] .stSlider, [data-testid="stSidebar"] input, [data-testid="stSidebar"] select {
                background: rgba(255,255,255,0.04);
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
            }
            .hero-card {
                position: relative;
                overflow: hidden;
                background: linear-gradient(125deg, #111a36 0%, #1f2750 60%, #1b4b6b 100%);
                padding: 36px 40px;
                border-radius: 32px;
                color: #f4f8ff;
                border: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 25px 70px rgba(5,10,22,0.65);
            }
            .hero-card::after {
                content: "";
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 80% 20%, rgba(255,255,255,0.18), transparent 45%);
                pointer-events: none;
                mix-blend-mode: screen;
            }
            .hero-card h1 {
                margin-bottom: 10px;
                font-size: 2.6rem;
                letter-spacing: -0.02em;
                position: relative;
                z-index: 1;
            }
            .hero-card p {
                position: relative;
                z-index: 1;
                opacity: 0.9;
                max-width: 700px;
            }
            .hero-copy {
                font-size: 1.05rem;
                line-height: 1.55;
            }
            .eyebrow {
                font-size: 0.85rem;
                letter-spacing: 0.25em;
                text-transform: uppercase;
                color: rgba(255,255,255,0.8);
                margin-bottom: 12px;
                display: inline-block;
            }
            .hero-meta {
                position: relative;
                z-index: 1;
                margin-top: 18px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
            }
            .hero-meta span {
                font-size: 0.85rem;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                padding: 6px 14px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,0.18);
                background: rgba(4,8,18,0.4);
            }
            .stat-card {
                background: var(--panel);
                border-radius: 22px;
                padding: 20px 24px;
                border: 1px solid var(--border);
                box-shadow: 0 18px 50px rgba(3,7,18,0.4);
            }
            .stat-label {
                text-transform: uppercase;
                font-size: 0.72rem;
                letter-spacing: 0.12em;
                color: rgba(255,255,255,0.85);
            }
            .stat-value {
                font-size: 2rem;
                font-weight: 600;
                margin-top: 8px;
                color: #f5f7ff;
            }
            .model-card {
                border-radius: 22px;
                padding: 24px 28px;
                background: var(--panel-solid);
                border: 1px solid var(--border);
                margin-top: 28px;
                box-shadow: 0 18px 45px rgba(5,8,20,0.45);
                color: #f6f8ff;
            }
            .model-card h3 {
                margin-bottom: 6px;
            }
            .model-footnote {
                margin-top: 12px;
                font-size: 0.85rem;
                color: var(--muted);
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
            .model-tag {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                background: var(--accent-soft);
                color: #ffd1bf;
                border-radius: 999px;
                padding: 4px 12px;
                border: 1px solid rgba(255,107,53,0.35);
            }
            .top-picks {
                margin: 18px 0 12px;
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                align-items: center;
            }
            .top-picks-title {
                font-size: 0.8rem;
                text-transform: uppercase;
                letter-spacing: 0.2em;
                color: var(--muted);
            }
            .chip {
                background: rgba(255,255,255,0.02);
                border-radius: 999px;
                padding: 6px 14px;
                border: 1px solid rgba(255,255,255,0.12);
                box-shadow: 0 6px 18px rgba(8,12,26,0.35);
                font-weight: 500;
                color: #f7f8ff;
            }
            div[data-testid="stDataFrame"] > div {
                border-radius: 26px;
                border: 1px solid rgba(255,255,255,0.12);
                background: #050913;
                box-shadow: 0 25px 70px rgba(5,8,20,0.65);
            }
            div[data-testid="stDataFrame"] table {
                color: #e4eaff;
                font-family: 'Space Grotesk', sans-serif;
                font-size: 0.95rem;
            }
            div[data-testid="stDataFrame"] tbody tr:hover {
                background: rgba(255,107,53,0.08) !important;
            }
            div[data-testid="stDataFrame"] thead {
                background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0));
                text-transform: uppercase;
                letter-spacing: 0.08em;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )
    st.markdown(f"<div class='{theme_class}'>", unsafe_allow_html=True)


def describe_user_profile(user_history: pd.DataFrame, item_df: pd.DataFrame) -> dict[str, str]:
    if user_history.empty:
        return {"count": "0", "avg": "-", "genres": "Chưa có dữ liệu"}
    avg_rating = round(float(user_history["rating"].mean()), 2)
    merged = user_history.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    genres = merged["genres"].dropna().str.split("|").explode()
    top_genres = ", ".join(genres.value_counts().head(2).index.tolist()) if not genres.empty else "-"
    return {
        "count": f"{len(user_history):,}",
        "avg": f"{avg_rating:.2f}",
        "genres": top_genres or "-",
    }


def render_top_picks(display_df: pd.DataFrame) -> None:
    if display_df.empty:
        return
    picks = display_df["Title"].head(3).tolist()
    chips = "".join(f"<span class='chip'>{title}</span>" for title in picks)
    st.markdown(
        f"""
        <div class="top-picks">
            <span class="top-picks-title">Spotlight</span>
            {chips}
        </div>
        """,
        unsafe_allow_html=True,
    )


def _genre_counts(source: pd.DataFrame, item_df: pd.DataFrame) -> pd.DataFrame:
    if source.empty:
        return pd.DataFrame(columns=["genre", "count"])
    merged = source.merge(item_df[["movieId", "genres"]], on="movieId", how="left")
    exploded = merged["genres"].dropna().str.split("|").explode()
    counts = exploded.value_counts().head(8).reset_index()
    counts.columns = ["genre", "count"]
    return counts


def build_insight_figures(
    user_history: pd.DataFrame, item_df: pd.DataFrame, ratings: pd.DataFrame
) -> tuple[Figure, Figure, str, str]:
    if len(user_history) >= 2:
        rating_source = user_history
        rating_label = "Phân bố rating của người dùng"
    else:
        rating_source = ratings.sample(min(len(ratings), 5000), random_state=42)
        rating_label = "Phân bố rating toàn bộ tập"

    fig_rating = px.histogram(
        rating_source,
        x="rating",
        nbins=10,
        labels={"rating": "Điểm"},
        color_discrete_sequence=["#ff6b35"],
    )
    fig_rating.update_layout(
        margin=dict(l=10, r=10, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )

    genre_counts = _genre_counts(user_history, item_df)
    if genre_counts.empty:
        genre_counts = _genre_counts(ratings, item_df)
        genre_label = "Top thể loại toàn bộ tập"
    else:
        genre_label = "Thể loại nổi bật của người dùng"

    fig_genre = px.bar(
        genre_counts,
        x="count",
        y="genre",
        orientation="h",
        labels={"count": "Số lần", "genre": "Thể loại"},
        color_discrete_sequence=["#8aa1ff"],
    )
    fig_genre.update_layout(
        margin=dict(l=70, r=20, t=10, b=10),
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        yaxis=dict(categoryorder="total ascending"),
    )

    return fig_rating, fig_genre, rating_label, genre_label


def build_usage_timeline(logs: list[dict]) -> tuple[pd.DataFrame, Figure | None]:
    if not logs:
        return pd.DataFrame(), None

    timeline_df = pd.DataFrame(logs)
    if timeline_df.empty:
        return timeline_df, None

    if "created_at" in timeline_df:
        timeline_df["created_at"] = pd.to_datetime(timeline_df["created_at"])
    else:
        timeline_df["created_at"] = pd.to_datetime(timeline_df.index)

    timeline_df.sort_values("created_at", inplace=True)
    timeline_df["end_at"] = timeline_df["created_at"] + timedelta(minutes=2)

    def _field(name: str, fallback: str = "-") -> pd.Series:
        series = timeline_df.get(name)
        if series is None:
            return pd.Series([fallback] * len(timeline_df), index=timeline_df.index)
        return series.fillna(fallback).astype(str)

    timeline_df["hover"] = (
        "User #" + timeline_df["user_id"].astype(str)
        + " · Model: " + _field("model_used", "?")
        + "<br>Movie: " + _field("movie_id")
        + "<br>Score: " + _field("score_shown")
        + "<br>Action: " + _field("action")
    )

    fig = px.timeline(
        timeline_df,
        x_start="created_at",
        x_end="end_at",
        y="user_id",
        color="model_used",
        hover_name="hover",
        labels={"user_id": "User", "model_used": "Model"},
        color_discrete_sequence=["#ff6b35", "#8aa1ff", "#46d4a5", "#f7b955"],
    )
    fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=60, r=20, t=30, b=20),
        legend_title_text="Thuật toán",
        yaxis=dict(title="User", tickmode="linear"),
        height=320,
    )
    return timeline_df, fig


def build_catalogue_figures(ratings: pd.DataFrame, item_df: pd.DataFrame) -> tuple[Figure, Figure, str, str]:
    agg = (
        ratings.groupby("movieId")["rating"].agg(["count", "mean"]).reset_index()
        .rename(columns={"count": "rating_count", "mean": "avg_rating"})
        .merge(item_df[["movieId", "clean_title", "genres"]], on="movieId", how="left")
    )

    top_popular = agg.sort_values("rating_count", ascending=False).head(8)
    scatter_source = agg[agg["rating_count"] >= 10].copy()
    if scatter_source.empty:
        scatter_source = agg.copy()
    if len(scatter_source) > 400:
        scatter_source = scatter_source.nlargest(400, "rating_count")

    pop_fig = px.bar(
        top_popular,
        x="rating_count",
        y="clean_title",
        orientation="h",
        labels={"rating_count": "Số lượt", "clean_title": "Phim"},
        color_discrete_sequence=["#ffd166"],
    )
    pop_fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=120, r=20, t=10, b=10),
        yaxis=dict(categoryorder="total ascending"),
    )

    scatter_fig = px.scatter(
        scatter_source,
        x="rating_count",
        y="avg_rating",
        size="avg_rating",
        color="avg_rating",
        hover_data={"clean_title": True, "genres": True},
        color_continuous_scale="Sunset",
        labels={"rating_count": "Số lượt", "avg_rating": "Điểm trung bình"},
    )
    scatter_fig.update_layout(
        template="plotly_dark",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=10, r=10, t=10, b=10),
    )

    return pop_fig, scatter_fig, "Top phim được đánh giá nhiều nhất", "Mối quan hệ lượt đánh giá vs. điểm"


MODEL_DESCRIPTIONS = {
    "Content-based": "Xây dựng fingerprint nội dung bằng TF-IDF thể loại/mô tả rồi xếp hạng các phim gần nhất với lịch sử của người dùng.",
    "Collaborative (SVD)": "Phân rã ma trận rating bằng SVD để học yếu tố tiềm ẩn user–item, tối ưu khi dữ liệu tương tác dày và đa dạng.",
    "Hybrid": "Pha trộn 55% collaborative và 45% content giúp vừa bám sát sở thích vừa mở rộng biên khám phá.",
}


def main() -> None:
    st.set_page_config(page_title="MovieLens Recommender", layout="wide")

    st.sidebar.subheader("Studio")
    theme_choice = st.sidebar.radio("Theme", ["Dark", "Light"], index=0, help="Đổi bảng màu tổng thể của dashboard để phù hợp môi trường trình chiếu.")
    alpha_default = 0.55
    hybrid_alpha = st.sidebar.slider(
        "Hybrid alpha",
        min_value=0.2,
        max_value=0.8,
        value=alpha_default,
        step=0.05,
        help="Điều chỉnh tỷ lệ trọng số giữa collaborative (cao) và content-based (thấp).",
    )
    inject_styles(theme_choice)

    content_model, collab_model, feature_store, item_df, ratings = get_models()
    hybrid_model = HybridRecommender(content_model=content_model, collab_model=collab_model, alpha=hybrid_alpha)

    user_ids = sorted(ratings["userId"].unique())
    st.sidebar.header("Điều hướng")
    user_id = st.sidebar.selectbox("User ID", user_ids, index=0, help="Chọn user thực tế từ MovieLens để xem lịch sử gợi ý cá nhân.")
    model_choice = st.sidebar.selectbox(
        "Model",
        ["Content-based", "Collaborative (SVD)", "Hybrid"],
        help="So sánh nhanh giữa ba chiến lược gợi ý đang triển khai.",
    )
    top_k = st.sidebar.slider(
        "Number of recommendations",
        min_value=5,
        max_value=20,
        value=10,
        help="Quy định số lượng phim xuất hiện trong bảng xếp hạng.",
    )
    genre_filter = st.sidebar.text_input(
        "Optional genre filter (e.g., Comedy)",
        help="Lọc nhanh theo thể loại quan tâm, hỗ trợ viết thường/hoa tự do.",
    )

    user_history = ratings[ratings["userId"] == user_id]

    if model_choice == "Content-based":
        recs = content_model.recommend(user_history, top_k=top_k)
    elif model_choice == "Collaborative (SVD)":
        recs = collab_model.recommend(user_id, item_df, top_k=top_k)
        recs = recs.rename(columns={"est_rating": "model_score"})
    else:
        recs = hybrid_model.recommend(user_id, user_history, top_k=top_k)
        recs = recs.rename(columns={"hybrid_score": "model_score"})

    if "model_score" not in recs.columns:
        recs["model_score"] = recs.get("score")

    base_display_cols = [
        "clean_title",
        "genres",
        "avg_rating",
        "rating_count",
        "model_score",
    ]

    if genre_filter:
        recs = recs[recs["genres"].str.contains(genre_filter, case=False, na=False)]

    logging_cols = [col for col in ["movieId", "model_score"] if col in recs.columns]
    auto_logged = False
    if telemetry_available() and "movieId" in recs.columns and not recs.empty:
        movie_ids = tuple(int(mid) for mid in recs["movieId"].tolist())
        signature = hash(
            (
                user_id,
                model_choice,
                top_k,
                (genre_filter or "").strip().lower(),
                movie_ids,
            )
        )
        last_sig = st.session_state.get("auto_log_sig")
        if movie_ids and signature != last_sig and logging_cols:
            inserted = log_recommendations(
                user_id,
                model_choice,
                recs[logging_cols],
                action="auto",
            )
            if inserted:
                st.session_state["auto_log_sig"] = signature
                auto_logged = True

    profile = describe_user_profile(user_history, item_df)
    st.markdown(
        """
        <div class="hero-card">
            <span class="eyebrow">MOVIELENS OPS · LIVE FEED</span>
            <h1>Bảng Điều Khiển Gợi Ý Chiến Lược</h1>
            <p class="hero-copy">Theo dõi phản ứng của ba thuật toán chủ đạo đối với từng người dùng cụ thể, so sánh tức thời và khóa lại cấu hình gợi ý phù hợp nhất trước khi đẩy sang môi trường triển khai.</p>
            <div class="hero-meta">
                <span>Pipeline đã làm sạch</span>
                <span>Artifacts versioned</span>
                <span>Giải thích trực quan</span>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )

    col_a, col_b, col_c = st.columns(3, gap="large")
    with col_a:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">LƯỢT ĐÁNH GIÁ</div>
                <div class="stat-value">{profile['count']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_b:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">ĐIỂM TRUNG BÌNH</div>
                <div class="stat-value">{profile['avg']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col_c:
        st.markdown(
            f"""
            <div class="stat-card">
                <div class="stat-label">THỂ LOẠI ƯA THÍCH</div>
                <div class="stat-value" style="font-size:1.2rem">{profile['genres']}</div>
            </div>
            """,
            unsafe_allow_html=True,
        )

    rating_fig, genre_fig, rating_label, genre_label = build_insight_figures(user_history, item_df, ratings)
    insight_col1, insight_col2 = st.columns(2, gap="large")
    with insight_col1:
        st.markdown(f"#### {rating_label}")
        st.plotly_chart(rating_fig, use_container_width=True, config={"displayModeBar": False})
    with insight_col2:
        st.markdown(f"#### {genre_label}")
        st.plotly_chart(genre_fig, use_container_width=True, config={"displayModeBar": False})

    pop_fig, scatter_fig, pop_label, scatter_label = build_catalogue_figures(ratings, item_df)
    global_col1, global_col2 = st.columns(2, gap="large")
    with global_col1:
        st.markdown(f"#### {pop_label}")
        st.plotly_chart(pop_fig, use_container_width=True, config={"displayModeBar": False})
    with global_col2:
        st.markdown(f"#### {scatter_label}")
        st.plotly_chart(scatter_fig, use_container_width=True, config={"displayModeBar": False})

    model_copy = MODEL_DESCRIPTIONS.get(model_choice, "")
    genre_phrase = f" · Lọc: {genre_filter.title()}" if genre_filter else ""
    alpha_phrase = f" · α={hybrid_alpha:.2f}" if model_choice == "Hybrid" else ""
    context_line = f"User #{user_id} · Top {top_k}{genre_phrase}{alpha_phrase}"
    st.markdown(
        f"""
        <div class="model-card">
            <div class="model-tag">Model Focus</div>
            <h3>{model_choice}</h3>
            <p>{model_copy}</p>
            <p class="model-footnote">{context_line}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

    st.subheader("Bảng xếp hạng đề xuất")
    display_df = recs[base_display_cols].rename(
        columns={"clean_title": "Title", "model_score": "Model Score"}
    )
    display_df = display_df.loc[:, ~display_df.columns.duplicated()]
    render_top_picks(display_df)
    st.dataframe(display_df, width="stretch", height=540)

    log_box = st.sidebar.container()
    if telemetry_available():
        if auto_logged:
            log_box.success("Đã tự động ghi nhận lịch sử cho cấu hình hiện tại.")
        if log_box.button(
            "Lưu thủ công", help="Nhấn khi muốn ép ghi lại log cho cấu hình này"
        ):
            if "movieId" not in recs.columns or not logging_cols:
                log_box.error("Không tìm thấy dữ liệu hợp lệ để ghi log.")
            else:
                inserted = log_recommendations(user_id, model_choice, recs[logging_cols], action="manual")
                if inserted:
                    log_box.success(f"Đã lưu {inserted} dòng vào MySQL")
                else:
                    log_box.warning("Không có bản ghi nào được lưu (bảng rỗng hoặc lỗi kết nối).")
    else:
        log_box.info("Thiết lập MYSQL_HOST/PORT/USER/PASSWORD/DATABASE để bật lưu lịch sử.")

    st.caption(
        "Dùng thanh bên để điều hướng giữa các chế độ và quan sát cách mỗi thuật toán tái cấu hình bảng xếp hạng trong thời gian thực."
    )

    if telemetry_available():
        with st.expander("Lịch sử tương tác (MySQL)", expanded=False):
            limit = st.slider("Số dòng gần nhất", min_value=5, max_value=50, value=15, step=5, key="log_limit")
            logs = list(fetch_recent_logs(limit=limit))
            if logs:
                log_df, timeline_fig = build_usage_timeline(logs)
                if timeline_fig is not None:
                    st.plotly_chart(timeline_fig, use_container_width=True, config={"displayModeBar": False})
                st.dataframe(log_df)
            else:
                st.info("Chưa có dữ liệu được ghi hoặc không thể kết nối MySQL.")


if __name__ == "__main__":
    main()
    st.markdown("</div>", unsafe_allow_html=True)

```


</details>
</tool-use>

---

**Updating theme text colors and adding charts**

I’m planning to lighten text colors specifically for the dark theme by updating CSS selectors like `.hero-card p` and `.stat-label` to use a bright color like `#f6f8ff`, while keeping the light theme text darker for contrast. Alongside this, I’ll add two new charts: a horizontal bar chart showing top movies by rating count and a scatter plot comparing rating count to average rating, using aggregated data from `ratings` and `item_df`. I’ll create helper functions to build these charts and integrate them in a new section below existing visuals. I’m also reviewing some warnings about `use_container_width` parameters to ensure compatibility without breaking the layout.**Adjusting .stat-label color****Adjusting text style in .model-card****Creating helper for global charts****Planning chart integration****Adding guards for empty dataframes****Reviewing UI styling and component structure****Analyzing Streamlit div injection timing**- To đáp ứng yêu cầu “chữ sáng”, mình cập nhật CSS trong `inject_styles()` để mặc định toàn bộ text trên theme tối dùng màu #f6f8ff và các thành phần như stat-label, model-card đều sáng rõ; theme sáng vẫn giữ màu đậm để đảm bảo tương phản `undefined`.
- Sidebar giờ có lựa chọn Theme + slider Hybrid alpha với tooltip, và hệ thống hiện alpha thực tế ngay trong phần “Model Focus” (khi chọn Hybrid) để stakeholder dễ kiểm soát `undefined` và `undefined`.
- Bổ sung thêm hai biểu đồ Plotly mới thông qua `build_catalogue_figures()`:
  - Top phim được đánh giá nhiều nhất (bar chart).
  - Quan hệ lượt đánh giá vs. điểm trung bình (scatter với mã màu Sunset).
  Những biểu đồ này xuất hiện ngay dưới bộ insight chính, mang lại cái nhìn “macro” cho kho phim `undefined` và `undefined`.

Server đang chạy nên chỉ cần refresh trang http://localhost:8501 để thấy theme sáng chữ cùng hai biểu đồ mới. Nếu cần mình có thể xử lý tiếp cảnh báo `use_container_width` hoặc tinh chỉnh palette Light.

---

